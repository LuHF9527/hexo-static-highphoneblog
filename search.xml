<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java内存模型(Java Memory Mode)</title>
      <link href="/cff6dd61.html"/>
      <url>/cff6dd61.html</url>
      
        <content type="html"><![CDATA[<h2 id="CPU-Cache模型"><a href="#CPU-Cache模型" class="headerlink" title="CPU Cache模型"></a>CPU Cache模型</h2><p>在学习JMM之前，我们先来了解下CPU Cache模型。在计算机中，所有的运算都由CPU来完成，而CPU计算需要从计算机主存(RAM)去读取数据，但是，我们都知道CPU的运算和读写速度很快，而主内存的读写速度要远远低于CPU，如果CPU要直接读取RAM，必将会大大降低CPU的速度和性能，于是就有了在CPU和主存之间增加了一层CPU Cache的设计。现在，CPU Cache分为三级，最靠近CPU的缓存叫做L1，然后一次是L2，L3和主内存，由于程序指令和程序数据的行为和热点分布差异很大，因此，L1缓存又被划分成了L1i(i是instuction的首字母)和L1d(d是data的首字母)这两种有各自专门用途的缓存。CPU缓存模型如下图所示: </p><p><img src="../images/2021-01-30-22-10-35.png"> </p><p>Cache 缓存模型是为了解决CPU直接访问内效率低下问题的，其工作原理如下：程序在运行过程中，会将运算所需要数据从主存复制一份到CPU Cache中，这样CPU计算的时候就可以直接对CPU Cache中的数据进行读取和写入，当运算结束之后，再将CPU Cache中的最新数据刷新到主内存中。CPU 通过访问CPU Cache的方式，大大提高了CPU的效率。</p><h2 id="CPU缓存一致性问题"><a href="#CPU缓存一致性问题" class="headerlink" title="CPU缓存一致性问题"></a>CPU缓存一致性问题</h2><p>引入CPU Cache来解决CPU直接读取主内存效率低下的问题，同时也会带来了CPU缓存不一致的问题。例如对于某个变量i的自增操作i++，具体过程如下：</p><ol><li>把变量i拷贝一份到CPU Cache中</li><li>CPU从缓存中读取i进行+1操作</li><li>CPU将计算后的i写回CPU Cache中</li><li>将数据从CPU Cache中刷新到主内存<br>以上过程，在单线程的情况下是没有问题的，但是在多线程的环境下就会有问题。每个线程都有自己的工作内存(对应于CPU的Cache)，如果有多个线程同时操作变量i，那么i在每个线程的工作内存中都有一份副本，假设线程i初始值是0，线程一和线程二同时读取到这个i的值，线程一想对i进行+1操作，而线程二进行-1操作，而这两个线程互相都不知道对方的操作，这样就有可能线程一先完成计算，把i的值变为1刷回主内存，但线程二仍然用0去做了-1操作，然后把-1刷回主内存，这样的计算是不正确的，这就是缓存一致性问题。<br>为了解决缓存一致性问题，通常有以下两种方式：  </li></ol><ul><li>通过总线加锁的方式<br>CPU和其他组件的通信都是通过总线来进行的，如果采用总线加锁的方式，会阻塞其他CPU对其他组件的访问，从而使得只有一个CPU(即一个线程)能够访问这个变量的内存。但是这种方式效率低下。  </li><li>缓存一致性协议<br>  最出名的缓存一致性协议是Intel的MESI协议，它保证了每一个缓存中使用的共享变量都是一致的。它的大致原理是：当CPU在操作Cache的数据时，如果操作的变量是一个共享变量(其他Cache也有这个变量的副本)，则有如下操作：<ol><li>对于读取操作，不做任何处理</li><li>对于写入操作，发出信号通知其他CPU将该变量的Cache Line设置为无效状态，其他CPU在进行该变量读取的时候将再次到主内存获取数据。</li></ol></li></ul><h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>Java的内存模型(Java Memory Mode, JMM)指定了Java虚拟机如何与计算机的主存(RAM)进行工作。它决定了一个线程对共享变量的写入何时对其他线程可见。JMM定义了线程和主内存之间的抽象关系，具体如下：</p><ol><li>共享变量放在主存中，每个线程都可以访问</li><li>每个线程都有各自的工作内存(也叫本地内存)</li><li>线程工作内存内只存储共享变量的副本</li><li>线程不能直接操作主内存，必须先操作工作内存后由工作内存写入主存</li><li>工作内存是抽象概念，其实并不存在，它涵盖了缓存、寄存器、编译器优化和硬件等。<br>Java内存模型如下图：<br><img src="../images/2021-01-31-11-36-24.png"></li></ol><h2 id="JMM与并发编程三大特性"><a href="#JMM与并发编程三大特性" class="headerlink" title="JMM与并发编程三大特性"></a>JMM与并发编程三大特性</h2><h3 id="JMM与原子性"><a href="#JMM与原子性" class="headerlink" title="JMM与原子性"></a>JMM与原子性</h3><ul><li><strong>原子性</strong>是指在一次或者多次操作中，要么所有的操作全部都得到了执行并且不会收到任何因素的干扰而中断，要么所有的操作都不执行，即<strong>要么都成功，要么都失败</strong>。最经典的例子就是银行转账业务。</li></ul><p>在JAVA中：</p><ul><li>多个原子性操作放到一起后就不再是原子性操作了，如i++</li><li>简单的读取与赋值操作是原子性的，将一个变量赋值给另外一个变量的操作不是原子性操作</li><li>Java内存模型只保证了基本读取和赋值的原子性操作，其他的均不保证。如果先要使某些代码片段具备原子性，需要使用关键字synchronized，或者使用JUC中的显示Lock。如果想要使得int类型自增操作具备原子性，可以使用JUC包下的原子封装类型java.util.concurrent.atomic.*。另外要注意的是<strong>Volatile关键字不具备保证原子性的语义</strong>。</li></ul><h3 id="JMM与可见性"><a href="#JMM与可见性" class="headerlink" title="JMM与可见性"></a>JMM与可见性</h3><ul><li><strong>可见性</strong>是指，当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值。</li></ul><p>在JAVA中，有以下三种方式可以保证可见性</p><ol><li>使用关键字Volatile，当一个变量被Volatile关键字修饰时，对于共享资源的读操作会直接在主存中进行(当然也会缓存到工作内存中，当其他线程对该共享资源进行了修改，则会导致当前线程在工作内存的共享资源失效，所以必须从主存中再次获取)，对于共享资源的写操作当然是要先修改工作内存，但是修改结束后会立刻将其刷新到主内存中。  </li><li>通过synchronized关键字可以保证可见性，它能保证同一时刻只有一个线程获得锁，然后执行同步方法，并且确保在释放锁之前，会将对变量的修改刷新到主内存中。</li><li>通过JUC提供的显示锁Lock也能保证可见性，Lock的lock方法能保证同一时刻只有一个线程获得锁，然后执行同步方法，并且确保在释放锁(unlock方法)之前会将对变量的修改刷新到主内存中。</li></ol><h3 id="JMM与有序性"><a href="#JMM与有序性" class="headerlink" title="JMM与有序性"></a>JMM与有序性</h3><ul><li><strong>有序性</strong>是指程序代码在执行过程中的先后顺序。一般来说，处理器为了提高程序运行的效率，可能会对输入的代码指令做一定的优化，它不会百分百的保证代码的执行顺序严格按照编写的代码中的顺序来执行(指令重排序 Instruction Recorder)，但是它会保证程序的最终运算结果是编码时所期望的那样。当然对指令的重排序要严格遵循指令之间的数据依赖关系，并不是可以任意进行重排序的。<br>如可见性一样，JAVA提供了三种方式保证有序性：</li></ul><ol><li>使用Volatile关键字来保证有序性<br> Volatile关键字语义直接禁止JVM和处理器对volatile关键字修饰的指令重排序。</li><li>使用synchronized关键字保证有序性<br> 加锁后，同步方法块或者代码块内代码同一时刻只有一个线程在执行，与单线程环境下执行是一样的，自然能保证顺序性(最终结果顺序性)</li><li>使用显示锁Lock保证有序性，与synchronized实现一样。</li></ol><h4 id="Happens-Before"><a href="#Happens-Before" class="headerlink" title="Happens-Before"></a>Happens-Before</h4><p>除了以上三种方式外，java内存模型天生具备一些有序性规则，不需要任何手段就能够保证有序性，这些规则被称为<strong>Happens-Before</strong>规则：</p><ul><li>程序次序规则<br>  在一个线程内，代码按照编写时的次序执行，编写在后面的操作发生在编写在前面的操作之后。虚拟机还是可能会对程序代码的指令进行重排序，但只要能确保在一个线程内最终的结果和代码顺序执行的结果一致即可(最终结果顺序性)。</li><li>锁定规则<br>  一个unlock操作要先行发生于对同一个锁的lock操作。这里是指，如果同一个锁是锁定状态，必须要先执行释放锁操作，才能再进行锁操作。</li><li>volatile变量规则<br>  对一个被volatile关键字修饰的变量，对这个变量写操作要早于对其的读操作执行</li><li>传递规则<br>  如果A操作先于B，B操作先于C，那么可以得出A操作先于C</li><li>线程启动规则<br>  Thread对象的start()方法先行发生于该线程的任何动作</li><li>线程的中断规则<br>  对线程执行interrupt()方法肯定要优先于捕获到中断信号</li><li>线程的终结规则<br>  线程的所有操作都要先行发生于线程的终止检测，即线程的任务执行、逻辑单元执行肯定要发生于线程死亡之前</li><li>对象的终结规则<br>  一个对象的初始化的完成先行发生于finalize()方法之前。</li></ul><blockquote><p>参考文献:《Java 高并发编程详解》-汪文君 著</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JMM </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/f1601c3e.html"/>
      <url>/f1601c3e.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>单例模式是GoF23中设计模式中最常见的设计模式中，它被用以在多线程环境中保持类的实例只有一个。</p></blockquote><h2 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h2><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> xyz.highphone.singleton;</span><br><span class="line"></span><br><span class="line"><span class="comment">//final 指定该类不可被继承，通常情况下，构造器私有后singleton类也不能被继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTon1</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义提供给外部调用的instance，static并在类加载的时候初始化，保证全局唯一</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingleTon1 instance = <span class="keyword">new</span> SingleTon1();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有，不允许外部代码new实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SingleTon1</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提供public static方法给外界获取单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SingleTon1 <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>饿汉式单例在多线程环境中能保证实例唯一，是安全的，同时由于在类加载的时候就已经创建实例了，所以在getInstance()的时候只需要返回实例引用即可，效率较高。<br>但是，由于是类加载的时候进行了new Instance操作，即不是懒加载的，所以单例类的实例变量也会被同时实例化，在堆中分配内存空间，这样可能会造成内存浪费。</p><h2 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h2><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义提供给外部调用的instance，类加载时先不初始化，在需要用到时才初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有，不允许外部代码new实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance)</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>懒汉式单例是懒加载方式，在第一次调用getInstance()时，才会去实例化单例。但是懒汉式单例在多线程环境中并不安全，当某线程进来判断null == instance时，会去进行实例化，而如果实例化还没完成，又有第二条线程进来，这是instance还是null，第二条线程也会去进行实例化，所以懒汉式单例在多线程环境可能存在多个实例。</p><h2 id="懒汉式-同步方法"><a href="#懒汉式-同步方法" class="headerlink" title="懒汉式 + 同步方法"></a>懒汉式 + 同步方法</h2><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton3</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义提供给外部调用的instance,类加载时先不初始化，在需要用到时才初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton3 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有，不允许外部代码new实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton3</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton3 <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton3();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>在懒汉式的基础上，通过给getInstance()方法加锁，可以让单例类在多线程中保证实例唯一，并且也实现了懒加载。但这种在整个方法上加锁的方式，让同一时刻只能有一个线程访问到getInstance()方法，这样非常影响性能。  </p><h2 id="Double-Check"><a href="#Double-Check" class="headerlink" title="Double-Check"></a>Double-Check</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton4</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义提供给外部调用的instance，类加载时先不初始化，在需要用到时才初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton4 instance = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//构造器私有，不允许外部代码new实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton4</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = <span class="string">&quot;张三&quot;</span>;<span class="comment">//实例化user</span></span><br><span class="line">        <span class="keyword">this</span>.address=<span class="keyword">new</span> Address();<span class="comment">//Address</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton4 <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton4.class)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == instance)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton4();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p>Double Check方式，即实现了懒加载，又保证了多线程环境下单例类的实例唯一，另外，在同一时刻只有一个线程能访问同步代码块，但是当单例创建后，后续多线程同时访问getInstance()时，instance都不为null，不需要再走同步代码块了，保证了效率。但是这种实现方式在多线程环境中有可能会引起空指针异常。<br>分析如下：<br>在某线程第一次进入getInstance()方法的时候，此时instance是null，此线程将获得锁，进行单例实例化操作，此单例的构造函数中，还实例化了另外两个对象user和address，即instance的实例化中，有如下三个步骤  </p><ol><li>实例化instance</li><li>实例化user</li><li>实例化address<br>因为这三个对象的实例化，并没有相互依赖的先后顺序，所以，根据JVM指令重排和Happens-Before原则，此时有可能是instance已完成实例化，但user和address还没完成实例化，而此时恰好有第二条线程调用getInstance()获取instance，对第二条线程来说，instance已经不为null了，返回instance使用，则使用instance调用成员变量user和address就会抛出空指针异常。</li></ol><h2 id="Volatile-Double-check"><a href="#Volatile-Double-check" class="headerlink" title="Volatile + Double-check"></a>Volatile + Double-check</h2><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton5</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义提供给外部调用的instance，类加载时先不初始化，在需要用到时才初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton5 instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有，不允许外部代码new实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton5</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = <span class="string">&quot;张三&quot;</span>;<span class="comment">//实例化user</span></span><br><span class="line">        <span class="keyword">this</span>.address=<span class="keyword">new</span> Address();<span class="comment">//Address</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton5 <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton5.class)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">null</span> == instance)</span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton5();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p>由于JVM指令重排序，让Double-Check方式在多线程环境下可能会出空指针异常，所以我们可以为instance静态变量增加<strong>Volatile</strong>关键字限定，禁止指令重排，这样，Volatile+Double-Check方式实现的单例模式，可以满足多线程下的唯一实例、懒加载及高效的特性。</p><h2 id="Holder方式"><a href="#Holder方式" class="headerlink" title="Holder方式"></a>Holder方式</h2><h3 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton6</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有，不允许外部代码new实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton6</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义私有的静态内部类，在内部类中定义Singleton6的实例，并且可以直接初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Holder</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Singleton6 instance = <span class="keyword">new</span> Singleton6();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在getInstance()中，调用静态内部类里面的instance成员变量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton6 <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Holder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h3><ul><li>在Singleton6的成员变量中，并没有instance静态成员变量，而是把instance放到了静态内部类Holder里面，这样，Singleton6类加载时其静态内部类Holder不会被加载，所以不会创建instance实例，当Holder被主动引用的时候才会创建instance实例，这样实现单例的方式满足了懒加载的特性。</li><li>Singleton6的创建过程会在程序编译时期收集至 <strong><clinit>()</clinit></strong> 方法中，而在《深入理解JAVA虚拟机》有这样的描述：<strong>虚拟机会保证一个类的<clinit>()方法在多线程的环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。</clinit></clinit></clinit></strong> 所以，Holder方式实现的单例模式，是可以满足多线程环境中的唯一实例，且高效率的特性的。Holder方式的单例设计是最好的设计之一，也是目前使用比较广的设计之一。</li></ul><h2 id="枚举方式"><a href="#枚举方式" class="headerlink" title="枚举方式"></a>枚举方式</h2><h3 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton7</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造器私有，不允许外部代码new实例</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton7</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//定义枚举类型的holder</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumHolder</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">//定义一个枚举实例对象，该对象天生就是单例的</span></span><br><span class="line">        INSTANCE;</span><br><span class="line">        <span class="keyword">private</span> Singleton7 instance;</span><br><span class="line">        EnumHolder()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.instance = <span class="keyword">new</span> Singleton7();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> Singleton7 <span class="title">getSingleton7</span><span class="params">()</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> instance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton7 <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> EnumHolder.INSTANCE.getSingleton7();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h3><p>枚举类型不允许被继承，同样是线程安全的，而且只能被实例化一次，同时instance定义在单例类内部的枚举类型中，也满足了懒加载特性。并且枚举类型只能被实例化一次，所以保证了单例不会被反射机制破坏掉，所以，从某种意义上来说，通过枚举来实现单例是最好的设计方式了。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> singleton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>8种基础排序算法</title>
      <link href="/87dda92b.html"/>
      <url>/87dda92b.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>基础环境准备：创建一个数据大小为n，数值为1000范围内的随机数组，调用排序方法，分别输出排序前和排序后的数组：  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = <span class="number">2000</span>;</span><br><span class="line">    <span class="keyword">int</span>[] array = createRandomArray(n);</span><br><span class="line">    System.out.println(<span class="string">&quot;Before Sorted:&quot;</span> + Arrays.toString(array));</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">    insertSort(array);</span><br><span class="line">    <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">    System.out.println(<span class="string">&quot;Sorted &quot;</span> + n + <span class="string">&quot; nums costs &quot;</span> + (end -start) + <span class="string">&quot;ms&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;After Sorted:&quot;</span> + Arrays.toString(array));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * create an array that contains n integer elements</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> int[]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] createRandomArray(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res[i] = random.nextInt(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 交换数组中下标为i和下标为j的位置</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> j</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = array[i];</span><br><span class="line">    array[i] = array[j];</span><br><span class="line">    array[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>从数组的第一个元素开始，即下标0开始，维护一个有序序列，从数组第一个元素开始遍历到数组结束，每个元素去前面维护的有序序列中找到自己的正确位置，然后插入有序序列中，外层遍历结束，数组就是有序的了。下图是插入排序动画演示：<br><img src="../images/insertionSort.gif"></p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处实现为由小到大升序排列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array != <span class="keyword">null</span> ? array.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1</span>) &#123; <span class="comment">//数组元素大于一个才有排序的必要</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = array[i];  <span class="comment">//待确定插入的元素</span></span><br><span class="line">            <span class="keyword">int</span> j = i; <span class="comment">//当前有序序列为[0, j-1]</span></span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; temp &lt; array[j - <span class="number">1</span>]) &#123;<span class="comment">//如果待插入元素比有序列表中的元素小，循环寻找合适的位置，知道找到小于等于待插入元素，或者没有找到(带插入元素为当前有序序列中最小的元素)</span></span><br><span class="line">                array[j] = array[j - <span class="number">1</span>];</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j != i) &#123;<span class="comment">//如果j有移动，即需要进行插入操作。</span></span><br><span class="line">                array[j] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序效果"><a href="#排序效果" class="headerlink" title="排序效果"></a>排序效果</h3><p>2000个值在0～1000之前的随机数组，排序耗时为5ms：<br><img src="../images/2021-01-17-15-29-06.png"></p><h3 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><ul><li>空间复杂度<br>  插入排序空间复杂度是O(1)。  </li><li>时间复杂度 </li></ul><ol><li>在最好情况下，给定待排序数组就是有序的，所以只需要从下标1到n-1遍历一边，此时时间复杂度是O(n-1)即**O(n)**。</li><li>在最坏情况下，给定待排序数组是逆序的，当外层为i是，内层循环需要判断的次数也为i，所以总次数为 1 + 2 + … + n -1 = n * (n-1) / 2 = 0.5(n^2) - 0.5n, 此时时间复杂度是O(n^2)。</li><li>在平均情况下，插入排序的时间复杂度也是O(n^2)，具体计算过程，见如下文章：<a href="https://www.cnblogs.com/icanth/archive/2012/06/12/2546250.html">插入排序——平均算法复杂度分析</a>  </li></ol><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h3 id="基本思想-1"><a href="#基本思想-1" class="headerlink" title="基本思想"></a>基本思想</h3><p>冒泡排序需要两层循环，外层循环控制总共需要进行多少次<strong>冒泡</strong>操作，内层循环则负责进行<strong>冒泡</strong>: 假设数组长度为n，当前是第i次冒泡操作，则需要在[0,n-1-i)区间内，对相邻的两个元素进行比较，把元素值大的元素放到相邻位置中靠后的位置(冒泡)。下图是冒泡动画演示:<br><img src="../images/bubbleSort.gif">  </p><h3 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 冒泡排序，从小到大升序排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array != <span class="keyword">null</span> ? array.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++) <span class="comment">//需要进行的冒泡次数：数组长度 - 1</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j++) <span class="comment">//当前冒泡操作需要比较的次数：数组长度 - 1 - i</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &gt; array[j + <span class="number">1</span>])  <span class="comment">//把大的元素放到相邻位置的靠后位置</span></span><br><span class="line">                &#123;</span><br><span class="line">                    swap(array, j, j + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序效果-1"><a href="#排序效果-1" class="headerlink" title="排序效果"></a>排序效果</h3><p>2000个值在0～1000之前的随机数组，排序耗时为9ms：<br><img src="../images/2021-01-17-16-50-57.png"></p><h3 id="时间复杂度和空间复杂度-1"><a href="#时间复杂度和空间复杂度-1" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><ul><li>空间复杂度<br>  冒泡排序空间复杂度是O(1)。  </li><li>时间复杂度 </li></ul><ol><li>在最好情况下，给定待排序数组就是有序的，外层循环次数是n-1次，内层循环仍然需要对相邻元素做比较判断，所以时间复杂度是 n - 1 + n-2 + … + 1 = n  * (n-1) / 2 = 0.5(n^2) - 0.5n, 此时时间复杂度是O(n^2)。</li><li>在最坏情况下，给定待排序数组是逆序的，此时循环的次数跟最好情况下是一样的，但此时内层循环除了要进行比较还要进行交换操作，所以耗时会比最好情况下多一些，但时间复杂度量级仍然是O(n^2)。</li><li>由上可知，在平均情况下，冒泡算法的时间复杂度也是O(n^2)。</li></ol><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="基本思想-2"><a href="#基本思想-2" class="headerlink" title="基本思想"></a>基本思想</h3><p>选择排序也是需要两层循环，外层循环控制<strong>选择</strong>操作的次数，内层循环中寻找第i次选择的元素，即第i小的元素。如果数组长度为n，外层循环遍历到第i次，内层循环<strong>选择</strong>操作需要遍历的次数为n - i - i。下图是选择排序动画演示：<br><img src="../images/selectionSort.gif">  </p><h3 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 选择排序，从小到大升序排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span>[] array)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array != <span class="keyword">null</span> ? array.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> min = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(array[j] &lt; array[min])</span><br><span class="line">                &#123;</span><br><span class="line">                    min = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(min != i)</span><br><span class="line">            &#123;</span><br><span class="line">                swap(array, i, min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序效果-2"><a href="#排序效果-2" class="headerlink" title="排序效果"></a>排序效果</h3><p>2000个值在0～1000之前的随机数组，排序耗时为8ms：<br><img src="../images/2021-01-17-17-38-38.png"></p><h3 id="时间复杂度和空间复杂度-2"><a href="#时间复杂度和空间复杂度-2" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><ul><li>空间复杂度<br>  选择排序空间复杂度是O(1)。  </li><li>时间复杂度 </li></ul><ol><li>在最好情况下，给定待排序数组就是有序的，外层循环次数是n-1次，内层循环进行选择的时候仍然需要进行判断，所以时间复杂度是 n - 2 + n-3 + … + 1 = (n - 1)  * (n-2) / 2 = 0.5(n^2) - 1.5n + 1, 此时时间复杂度是O(n^2)。</li><li>在最坏情况下，给定待排序数组是逆序的，此时循环的次数跟最好情况下是一样的,所以此时时间复杂度仍然是O(n^2)。</li><li>由上可知，在平均情况下，选择排序算法的时间复杂度也是O(n^2)。</li></ol><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><h3 id="基本思想-3"><a href="#基本思想-3" class="headerlink" title="基本思想"></a>基本思想</h3><ol><li>快速排序通常需要设定一个基准数，以基准数来遍历数组，把所有大于基准数的数组元素放在基准数右边，所有小于基准数的数组元素放在基准数左边，这样，以基准数为中心，把数组分成了左半边和右半边两部分数组(分而治之思想)。</li><li>再利用递归思想，分别把左边和右边两部分分别再重复步骤一。<br>算法步骤如下图:<br><img src="../images/2021-01-17-23-19-20.png"></li></ol><h3 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/***</span></span><br><span class="line"><span class="comment"> * 快速排序，二分思想&amp;递归</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> array</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = array != <span class="keyword">null</span> ? array.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (len &gt; <span class="number">1</span> &amp;&amp; left &lt; right) <span class="comment">//数组长度 &gt; 1 &amp; 左边界小于右边界 </span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> temp = array[left];  <span class="comment">//基准数</span></span><br><span class="line">        <span class="keyword">int</span> i = left;</span><br><span class="line">        <span class="keyword">int</span> j = right;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j)<span class="comment">//遍历寻找，把所有比基准数大的数放回右边，所有比基准数小的数放回左边</span></span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">while</span> (array[j] &gt;= temp &amp;&amp; i &lt; j)<span class="comment">//寻找比基准数小的数</span></span><br><span class="line">               j--;</span><br><span class="line">           <span class="keyword">while</span>(array[i] &lt;= temp &amp;&amp; i &lt; j) <span class="comment">//寻找比基准数大的数</span></span><br><span class="line">               i++;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span>(i &lt; j)  <span class="comment">//如果比基准数大的数在左边，比基准数小的数在右边，交换位置</span></span><br><span class="line">           &#123;</span><br><span class="line">               swap(array, i, j);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(array, left, i); <span class="comment">//把基准数放到数组中间</span></span><br><span class="line">        quickSort(array, left, i - <span class="number">1</span>); <span class="comment">//递归处理左区间</span></span><br><span class="line">        quickSort(array, i + <span class="number">1</span>, right);<span class="comment">//递归处理右区间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="排序效果-3"><a href="#排序效果-3" class="headerlink" title="排序效果"></a>排序效果</h3><p>2000个值在0～1000之前的随机数组，排序耗时为1ms：<br><img src="../images/2021-01-17-23-46-35.png"> </p><h3 id="时间复杂度和空间复杂度-3"><a href="#时间复杂度和空间复杂度-3" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h3><blockquote><p>快速排序的空间复杂度与时间复杂度归纳过程涉及到更多的数学知识，这里不做详尽展开，具体可参考博文<a href="https://blog.csdn.net/weshjiness/article/details/8660583">快速排序最好，最坏，平均复杂度分析</a>  </p></blockquote><ul><li>空间复杂度<br>  快速排序空间复杂度与其递归深度有关，最好情况，递归树的深度为log2n，其空间复杂度也就为O(logn)，最坏情况，需要进行n‐1递归调用，其空间复杂度为O(n)，平均情况，空间复杂度也为O(logn)。  </li><li>时间复杂度 </li></ul><ol><li>在最好情况下，快速排序算法的时间复杂度为O(nlogn)。</li><li>在最坏的情况下，其时间复杂度为O(n^2)。</li><li>在平均情况下，其时间复杂度为O(nlogn)。</li></ol><blockquote><p>未完待续</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序 </tag>
            
            <tag> 算法基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存回收策略</title>
      <link href="/8cd769c.html"/>
      <url>/8cd769c.html</url>
      
        <content type="html"><![CDATA[<h2 id="判断对象“已死”"><a href="#判断对象“已死”" class="headerlink" title="判断对象“已死”"></a>判断对象“已死”</h2><blockquote><p>大多数对象实例都在堆中，垃圾收集器在对堆进行回收前，需要先确定哪些对象还“存活”，哪些对象已经“死去”(即不可能再被任何途经使用的对象)。判断对象已死常用算法有 <strong>引用计数法和可达性分析算法</strong></p></blockquote><h3 id="引用计数法-Reference-Counting"><a href="#引用计数法-Reference-Counting" class="headerlink" title="引用计数法(Reference Counting)"></a>引用计数法(Reference Counting)</h3><p>在引用计数法中，会给每个对象添加一个引用计数器，每当有一个地方引用到这个对象时，这个对象的引用计数器加1；当有一个这个对象的引用失效时，引用计数器减1，那些引用计数器为0的对象，就是不可能再被使用的，引用计数法就认为这个对象“已死”。<br>引用计数法的优点是实现简单，判定效率也很高，在一些情况下它是一个不错的算法。但是它的缺点也非常明显：首先，为每个对象分配内存时，需要为引用计数器分配额外内存，最致命的是，引用计数法无法解决循环引用的问题:  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReferenceCountingTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object reference = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ReferenceCountingTest objectA = <span class="keyword">new</span> ReferenceCountingTest();</span><br><span class="line">        ReferenceCountingTest objectB = <span class="keyword">new</span> ReferenceCountingTest();</span><br><span class="line">        objectA.reference = objectB;</span><br><span class="line">        objectB.reference = objectA;</span><br><span class="line">        objectA = <span class="keyword">null</span>;</span><br><span class="line">        objectB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上面的代码，objectA和ObjectB中都有一个reference成员变量，objectA的reference指向objectB，objectB的reference指向objectA，当objectA和objectB都赋值为null后，在我们认为，这两个都已经是垃圾对象了，是可以被回收的，但是由于objectA和objectB相互被对方的referenc引用，所以他们的引用计数器都是1，如果使用引用计数法判断，那么这两个对象都是“存活”的，不会被回收。</p><blockquote><p>备注：可以使<a href="https://www.jianshu.com/p/4d59698030f1">Recycler-环状引用计数法</a>来解决循环引用的问题(了解), 但是在多线程环境下，引用计数变更也要进行昂贵的同步操作，性能较低。</p></blockquote><h3 id="可达性分析-Reachability-Analysis-算法"><a href="#可达性分析-Reachability-Analysis-算法" class="headerlink" title="可达性分析(Reachability Analysis)算法"></a>可达性分析(Reachability Analysis)算法</h3><p>由于引用计数法无法解决循环引用的问题，所以在JVM中没有采用这个算法进行判读对象是否“已死”，而是使用了<strong>可达性分析算法</strong>。<br>在可达性分析算法中，以一系列成为<strong>GC ROOT</strong>的对象为起点，从这些节点开始往下搜索，搜索的路径叫做引用链(Reference Chain)。对于一个对象，如果没有任何<strong>GC ROOT</strong>可以通过引用链找到这个对象(不可达)，则证明这个对象是不可用的。这样，即使内存中有类似与上面循环引用的对象，如果通过<strong>GC ROOT</strong>不可达，那也可以正确判定这些对象是可回收的对象。  </p><h4 id="GC-ROOT"><a href="#GC-ROOT" class="headerlink" title="GC ROOT"></a>GC ROOT</h4><p>在Java中，以下几种对象可以作为GC ROOT对象：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI(Native方法)引用的对象。</li></ul><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><blockquote><p>“引用”与判断对象是否存活息息相关。在JDK1.2之前，对于引用的定义是这样的：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。<br>在JDK1.2之后，Java对“引用”的概念进行了扩充，将“引用”分为了<strong>强引用(Strong Reference)、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）</strong>4种，引用强度依次减弱。  </p></blockquote><ul><li><p>强引用(Strong Reference)<br>强引用在程序代码中普遍存在，类似与使用new创建对象实例这种引用就是强引用。只要一个对象存在强引用，垃圾收集器回收内存垃圾时就不会回收这个对象。  </p></li><li><p>软引用（Soft Reference）<br>软引用用来描述一些还有用但非必须的对象。在系统将要发生OOM时，会把这些对象列进回收范围进行第二次回收，如果二次回收后还没有足够的内存，才会抛出OOM。JDK1.2后提供了java.lang.ref.SoftReference类实现软引用。应用场景: 软引用可用于实现内存敏感的高速缓存。如果内存充足，就可以一直把缓存放在内存中，加快数据访问速度。如果内存不足了，缓存就会被回收掉。  </p></li><li><p>弱引用（Weak Reference）<br>被弱引用引用的对象，只能存活到下一次垃圾收集发生前，当下一进行垃圾收集时，无论内存是否充足，弱引用对象都会被回收。JDK1.2后提供了java.lang.ref.WeakReference来实现弱引用。</p></li><li><p>虚引用（Phantom Reference）<br>一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用来获取对象实例。设置虚引用通常是为了让这个对象被垃圾收集器回收时，能收到一个系统通知。在JDK1.2后，提供了java.lang.ref.PhantomReference类来实现虚引用。</p></li></ul><h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记-清除-Mark-Sweep-算法"><a href="#标记-清除-Mark-Sweep-算法" class="headerlink" title="标记-清除(Mark-Sweep)算法"></a>标记-清除(Mark-Sweep)算法</h3><p>标记-清除算法算法分为两个阶段，第一阶段是追踪(Tracing)阶段：从GC Root开启沿着引用链遍历对象图,并标记(Mark)所遇到的对象。第二阶段是清除(Sweep)阶段,垃圾回收器检查堆中所有对象，并将所有未被标记的对象回收。标记-清除算法是基础收集算法，实现简单，不需要额外的移动对象的操作。它主要存在两个问题：标记和清除两个过程的效率不高、标记清除后可能会产生大量不连续的内存碎片。  </p><h3 id="复制-Copying-算法"><a href="#复制-Copying-算法" class="headerlink" title="复制(Copying)算法"></a>复制(Copying)算法</h3><p>复制算法是为了解决效率问题提出的，它将可用内存容量划分为大小相等的两块，每次只使用其中一块。当使用的一块中内存满了，就将还存活的对象复制到另一块空的内存中，复制完后清除已使用的一块内存空间。复制算法的优点是实现简单，运行高效，不用考虑内存碎片问题。缺点是需要浪费一半的内存空间，同时，如果存活对象中有大对象时，复制成本太高，也正是因为复制需要成本，所以复制算法适用于对对象存活率不高的区域进行垃圾回收，这样，需要复制的对象不多，效率会很高。  </p><ul><li>经IBM公司专门的研究表明，JVM新生代中98%的对象都是”朝生夕死”，所以，新生代对象回收非常适合使用复制算法来进行垃圾回收。因为只有大约2%的对象存活，所以还可以对复制算法进行优化：在默认情况下，在新生代中内存按照<strong>8:1:1</strong>的比例分为了<strong>Eden Space、Survivor From、Survivor To</strong>三个区域，每次垃圾收集发生时，都将<strong>Eden Space、Survivor From</strong>区域中还存活的对象复制到<strong>Survivor To</strong>区中，然后清理<strong>Eden Space、Survivor From</strong>区域内存，这样每次留空(“浪费”)的内存只占用了新生代内存区域的10%。</li><li>当然，在某些极端场景下，我们没有办法保证每次祸首都只有不多于10%的对象存活，当<strong>Survivor To</strong>区中内存不足以放下单次垃圾回收中还存活的对象时，这些对象将通过 <strong>分配担保(Handle Promotion)</strong> 机制直接进入老年代。</li></ul><h3 id="标记-整理-Mark-Compact-算法"><a href="#标记-整理-Mark-Compact-算法" class="headerlink" title="标记-整理(Mark-Compact)算法"></a>标记-整理(Mark-Compact)算法</h3><p>标记-整理算法也叫标记-压缩算法，在标记阶段于标记-清除算法一样，但标记完成后，不会直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理端边界以外的内存。在老年代的垃圾收集中，对象存活的比率比较高，不适合使用复制算法，一般会使用标记-整理算法进行垃圾收集。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>上面三种算法中包含的操作，时间与空间效率总结如下表，用L代表存活对象数量，H代表堆大小：  </p></blockquote><table><thead><tr><th>收集算法</th><th>包含动作</th><th>是否移动对象</th><th>空间开销</th><th>时间开销</th></tr></thead><tbody><tr><td>标记-清除(Mark-Sweep)算法</td><td>Mark、Sweep</td><td>否</td><td>低(有碎片)</td><td>Mark时间与L成正比O(L) + Sweep时间与H成正比O(H)</td></tr><tr><td>复制(Copying)算法</td><td>Copying</td><td>是</td><td>高</td><td>Coying与L成正比O(L)</td></tr><tr><td>标记-整理(Mark-Compact)算法</td><td>Mark、Compaction</td><td>是</td><td>低(没碎片)</td><td>Mark时间与L成正比O(L) + Compaction时间与L成正比O(L)</td></tr></tbody></table><p>把 mark、sweep、compaction、copying 这几种动作的耗时放在一起看，大致有这样的关系：<br><img src="../images/2021-01-16-14-13-05.png"></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
            <tag> GC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java堆及虚拟机栈</title>
      <link href="/9a65291d.html"/>
      <url>/9a65291d.html</url>
      
        <content type="html"><![CDATA[<h2 id="Java虚拟机栈-Java-Vitual-Mechine-Stack"><a href="#Java虚拟机栈-Java-Vitual-Mechine-Stack" class="headerlink" title="Java虚拟机栈(Java Vitual Mechine Stack)"></a>Java虚拟机栈(Java Vitual Mechine Stack)</h2><p>在之前的<a href="/3e83b217.html">JVM内存模型</a>一文已经对java虚拟机栈又一个初步的概述了，现在我们再来看看关于栈帧的一些相关内容。<br>我们知道，栈是线程私有的，每个方法被调用时会在当前线程栈内存中创建一个栈帧，如下图：<br><img src="../images/!%5B%5D(../images/2021-01-10-15-02-22.png).png">  </p><h3 id="栈帧-Stack-Frame"><a href="#栈帧-Stack-Frame" class="headerlink" title="栈帧(Stack Frame)"></a>栈帧(Stack Frame)</h3><ul><li>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构,它是虚拟机运行时数据区中的java虚拟机栈的栈元素。  </li><li>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息。  </li><li>正在被线程执行的方法称为当前线程方法，而该方法的栈帧就称为当前帧，执行引擎运行时只对当前栈帧有效。</li><li>在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写人到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。  </li></ul><ol><li><p>局部变量表(Local Variable Table)<br> 局部变量表(Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时就在方法的code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><ul><li>局部变量槽(Variable Slot)<br>  局部变量表的容量以变量槽为最小单位。每个变量槽都可以存储32位长度的内存空间，例如boolean、byte、char、short、int、float、reference(对象实例的引用) 和 returnAddress类型（它指向了一条字节码指令的地址）。对于64位长度的数据类型(long，double），虚拟机会以高位对齐方式为其分配两个连续的Slot空间，也就是相当于把一次long和double数据类型读写分割成为两次32位读写。</li></ul></li><li><p>操作数栈(Operand Stack）<br> 操作数栈也同局部变量表一样，操作数栈的最大深度也在编译的时候写人到code属性的max_stacks数据项中。操作数栈的每一个元素可以是任意的Java数据类型，包括long和double。32位数据类型所占的栈容量为1，64位数据类型所占的栈容量为2。在方法执行的任何时候，操作数栈的深度都不会超过在maxstacks数据项中设定的最大值。</p></li><li><p>动态链接(Dynamic Linking)<br> Class文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p></li><li><p>方法出口<br> 当一个方法开始执行后，只有2种方式可以退出这个方法:  </p><ul><li><p>方法返回指令: 执行引擎遇到一个方法返回的字节码指令，这时候有可能会有返回值传递给上层的方法调用者，这种退出方式称为正常完成出口。</p></li><li><p>异常退出: 在方法执行过程中遇到了异常，并且没有处理这个异常，就会导致方法退出。  </p><p>无论采用任何退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p></li></ul></li></ol><h2 id="Java堆-Java-Heap"><a href="#Java堆-Java-Heap" class="headerlink" title="Java堆(Java Heap)"></a>Java堆(Java Heap)</h2><p>JVM中只有一个堆，供所有线程共享，java堆可以细分为年轻代(Young Generation)、老年代(Old Generation)和永久代(permanent Generation)，其中新生代又分为伊甸园区(Eden Space)、幸存0区(Survivor0 Space)、幸存1区(Survivor1 Space)。永久代是JDK1.7以前，对JVM方法区的实现，在《深入理解JVM》一书中有如下描述: 虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap(非堆)，目的应该是与Java堆区分开来。在JDK1.8以后，移除了永久代，改用元空间(Meta Space)来实现方法区，元空间放在直接内存中。  </p><ul><li>JDK1.7堆内存结构图<br><img src="../images/2021-01-10-21-52-20.png"></li><li>JDK1.8 堆内存结构图<br><img src="../images/2021-01-10-21-52-50.png"></li></ul><h3 id="年轻代-Young-Generation"><a href="#年轻代-Young-Generation" class="headerlink" title="年轻代(Young Generation)"></a>年轻代(Young Generation)</h3><blockquote><p>在整个Java Heap中，年轻代所占用内存大小的比例是1/3  </p></blockquote><ol><li>伊甸园区(Eden Space)<br> 整个年轻代可以分成10份，伊甸园区所占内存大小是8/10。大多数情况下，新生的对象会在Eden区分配内存，当Eden区内存不足的时候，会触发一次轻GC(Minor GC)。</li><li>幸存0区和幸存1区(Survivor0 Space和Survivor1 Space)<br>幸存0区和幸存1区也叫做幸存From区(SurvivorFrom)和幸存To区(SurvivorTo)，Eden、SurvivorFrom和SurvivorTo内存比例是<strong>8:1:1</strong>。SurvivorFrom中保存了上一次MinorGc中幸存的对象，SurvivorTo区中会保存本次MinorGc中Eden Space和SurvivorFrom中幸存的对象，MinorGc过后，SurvivorFrom区对象被清空，那么下一次MinorGc时，他就会变成SurvivorTo区，而上一次的SurvivorTo则成为SurvivorFrom区。</li></ol><h3 id="老年代-Old-Generation"><a href="#老年代-Old-Generation" class="headerlink" title="老年代(Old Generation)"></a>老年代(Old Generation)</h3><blockquote><p>在整个Java Heap中，年轻代所占用内存大小的比例是2/3  </p></blockquote><p>在默认情况下，如果幸存区中有对象经过了15次MinorGc还没被回收，这个对象就会就进入老年代,对象进入老年代所经过MinorGc的次数可以通过JVM提供的 <code>-XX:MaxTenuringThreshold</code> 参数指定。另外，上面说了大多数情况下，新生的对象会在Eden区分配内存，但是这不包括大对象，大对象是直接进入老年代的。所谓大对象是指，需要大量连续内存空间的java对象，最典型的大对象就是那种很长的字符串或者数组，虚拟机提供了一个 <code>-XX:PretenureSizeThreshold</code> 参数，令大于这个设置值的对象直接在老年代分配内存。  </p><p>除了以上情况，《深入理解JVM》中还有如下描述：为了能更好地适应不同程序的内存状况，虚拟机并不是永远的要求对象的年龄必须达到了<code>MaxTenuringThreshold</code>才能晋升老年代，<strong>如果Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代，无需等到<code>MaxTenuringThreshold</code>中要求的年龄</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java类加载机制及类加载器</title>
      <link href="/3d2798f3.html"/>
      <url>/3d2798f3.html</url>
      
        <content type="html"><![CDATA[<h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>在《深入理解Java虚拟机》第二版中，关于类的生命周期是如下定义的：<br>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括<strong>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)、使用(Using)、卸载(UnLoading)</strong> 七个阶段，其中类加载过程包括 <strong>加载(Loading)、验证(Verification)、准备(Preparation)、解析(Resolution)、初始化(Initialization)</strong> 这五个阶段,如下图<br><img src="../images/2021-01-09-17-17-18.png">  </p><h3 id="加载-Loading"><a href="#加载-Loading" class="headerlink" title="加载(Loading)"></a>加载(Loading)</h3><p>在加载阶段，虚拟机需要做3个事情</p><ol><li>通过类的全限定名获取该类的二进制字节流(.class)</li><li>将二进制字节流所代表静态存储结构转化为方法区中的运行时数据结构</li><li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。(相当于这个类生成实例对象的模版)  </li></ol><h3 id="验证-Verification）"><a href="#验证-Verification）" class="headerlink" title="验证(Verification）"></a>验证(Verification）</h3><p>验证这一阶段是为了确保Class文件的字节流中包含的信息是否符合虚拟机的要求，并且不会危害虚拟机自身的安全，这一阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。在这一阶段，大致上会完成对以下4方面的校验动作:  </p><ol><li>文件格式验证<br> 验证二进制字节流是否符合Class文件格式的规范，并且能被当前版本虚拟机处理。</li><li>元数据验证<br> 对字节流中的所描述的信息进行语义分析，确保不存在不符合java语言规范的元数据信息.</li><li>字节码验证<br> 主要通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。与元数据验证不同的是，在元数据验证阶段是对元数据信息中的数据类型做校验，而字节码校验是对类的方法体进行校验分析，保证被校验类的方法在运行时不会作出危害虚拟机安全的事件。</li><li>符号引用验证<br> 符号引用验证可以看作是对类自身以外的信息进行匹配行校验(如常量池中的各种符号引用)</li></ol><h3 id="准备-Preparation"><a href="#准备-Preparation" class="headerlink" title="准备(Preparation)"></a>准备(Preparation)</h3><p>准备阶段会在方法区正式中为类变量分配内存并设置初始值，此处说的类变量是指有static修饰的静态变量，而并非指类实例变量，类实例变量会随类对象实例化时一起在堆中分配内存。  </p><h3 id="解析-Resolution"><a href="#解析-Resolution" class="headerlink" title="解析(Resolution)"></a>解析(Resolution)</h3><p>解析阶段是虚拟机将常量池内的符号引用替换成直接引用的过程。  </p><ul><li>符号引用(Symbolic References)<br>  以一组符号来描述所引用的目标。符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可,其引用的目标不一定已经加载到内存中。</li><li>直接引用(Direct REferences)<br>  直接引用可以是直接指向目标的指针、相对偏移量或一个能间接定位到目标的句柄。如果有了直接引用，那直接饮用的目标必定已经被加载到内存中。</li></ul><h3 id="初始化-Initialization"><a href="#初始化-Initialization" class="headerlink" title="初始化(Initialization)"></a>初始化(Initialization)</h3><p>类初始化阶段是类加载过程的最后一步，在这一阶段，会根据程序员通过程序制定的主观计划去初始化类变量和其他资源，从另外一个角度来看，初始化就是执行类构造器方法的过程。  </p><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><blockquote><p><strong>Java类加载器（Java Classloader</strong>）是Java运行时环境（Java Runtime Environment）的一部分，负责动态加载Java类到Java虚拟机的内存空间中。JVM中有3个默认的类加载器，分别是<strong>启动类类加载器(BootStrap ClassLoader)、扩展类类加载器(Extension ClassLoader)、应用程序类加载器(Application ClassLoader)</strong></p></blockquote><h3 id="启动类类加载器-BootStrap-ClassLoader"><a href="#启动类类加载器-BootStrap-ClassLoader" class="headerlink" title="启动类类加载器(BootStrap ClassLoader)"></a>启动类类加载器(BootStrap ClassLoader)</h3><p>在HotSpot虚拟机中，启动类加载器是有C++语言实现的，是虚拟机自身的一部分。启动类加载器负责将放在%JAVA_HOME%\lib目录中，或者被-Xbootclasspath参数所指定的，并且是虚拟机能通过文件名识别(如rt.jar的类库加载到虚拟机内存中)。启动类加载器无法被java程序直接引用  </p><h3 id="扩展类类加载器-Extension-ClassLoader"><a href="#扩展类类加载器-Extension-ClassLoader" class="headerlink" title="扩展类类加载器(Extension ClassLoader)"></a>扩展类类加载器(Extension ClassLoader)</h3><p>这个类加载器有sun.misc.Launcher$ExtClassLoader实现，它负责加载%JAVA_HOME%\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。  </p><h3 id="应用程序类加载器-Application-ClassLoader"><a href="#应用程序类加载器-Application-ClassLoader" class="headerlink" title="应用程序类加载器(Application ClassLoader)"></a>应用程序类加载器(Application ClassLoader)</h3><p>由于这个类是java.lang.ClassLoader中getSystemClassLoader()的返回值，所以也叫系统类加载器，由sun.misc.Launcher$AppClassLoader实现。应用程序类加载器负责加载用户类路径(ClassPath)上所指定的类库。如果开发者没有自定义自己的类加载器，这个类加载器就是程序中的默认类加载器。   </p><h2 id="双亲委派模型-Parents-Delegation-Model"><a href="#双亲委派模型-Parents-Delegation-Model" class="headerlink" title="双亲委派模型(Parents Delegation Model)"></a>双亲委派模型(Parents Delegation Model)</h2><blockquote><p>在双亲委派模型中，要求除了启动类加载器外，其余的类加载器都应当有自己的父类加载器。这里类加载器的父子关系一般不会以继承来实现，而是都使用组合关系来复用父类加载器的代码(例如子类加载器中通过成员变量方式调用父类加载器的代码)。  </p></blockquote><p><img src="../images/2021-01-09-21-50-58.png">  </p><p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，它不会先尝试自己去加载这个类，而是把这个类向上委派给父类加载器，父类加载器也会重复向上委派这个步骤，直到顶层启动类加载器。因此，所有的类加载请求最终都会被委派到最顶层的启动类加载器中，这样从上往下尝试去加载这个类，只有当父类加载器无法完成这个类的加载请求(在此类加载器的搜索范围中没有找到需要加载的类)时，子加载器才会尝试自己去加载。  </p><p>在双亲委派模型中，一个明显的好处就是，jdk自带的类库，会随着它的类加载器具备了优先加载的层级关系，这样可以保证jdk自带的类在程序的各种类加载环境中都是同一个类。例如，在不违反双亲委派模型的前提下，即使你自定义一个java.lang.Object类，在编译期也没有报错，但是这个类永远都不会加载到内存中，加载到内存的只会是jdk自带的java.lang.Object类。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务学习笔记</title>
      <link href="/fb1220e7.html"/>
      <url>/fb1220e7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>事务（Transaction）是访问和更新数据库的程序执行单元；事务中可能包含一个或多个sql语句，这些语句要么都执行，要么都不执行。在mysql中，事务是由存储引擎实现的，mysql有两种存储引擎，一种是InnoDB，另一种是Myisam，由于Myisam引擎不支持事务，所以这里讨论的事务都是基于InnoDB存储引擎的。</p></blockquote><h2 id="mysql事务四大原则-ACID"><a href="#mysql事务四大原则-ACID" class="headerlink" title="mysql事务四大原则(ACID)"></a>mysql事务四大原则(ACID)</h2><ol><li><p>原子性(Atomicity)<br>事务是一个不可分割的工作单位，同一组事务的操作，要么都成功(持久化)，要么都失败(事务回滚)。例如我有600元，张三有300元，我给张三转账100元，这个过转账过程在同一组事务中，如果整个事务没有异常，那执行转账的所有操作，事务正常提交后，我的钱变成500，张三的钱变成400，这个结果就持久化到数据库了(都成功)。但是如果在我的钱已经转出(-100操作)，而张三的钱还没到账(+100操作)的时候，由于数据库宕机、其中一条sql语句执行不成功等不可预知的因素，造成这组转账事务还没来得及全部完成，在数据库恢复后，就会执行回滚操作，我的钱依然是600，张三的钱依然是300(都失败)。</p></li><li><p>一致性(Consistency)<br> 保证事务操作前和操作后的数据或者数据结构的一致性。例如，在上面的转账例子中，我和张三的钱总共是600+300=900元，在一组转账事务的前后，我们的总的钱这个数据是一致的。</p></li><li><p>隔离性(Isolation)<br> 隔离性是指，事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</p></li><li><p>持久性(Durability)<br> 事务一旦提交，就是不可逆的，事务中的操作会被持久化到数据库，不应该被数据库故障或者接下来的其他操作所影响。</p></li></ol><h2 id="mysql事务日志"><a href="#mysql事务日志" class="headerlink" title="mysql事务日志"></a>mysql事务日志</h2><p>在mysql中，与事务相关的日志有三种，分别是bin log(二进制日志),redo log(重做日志), undo log(回滚日志)，其中bin log是用mysql server层实现的，而redo log和undo log使用InnoDB存储引擎实现的。此处只是对事务日志做一个简述，没有深入展开。这里插个眼:<a href="https://htchz.cc/categories/Mysql/">mysql三种事务日志</a></p><ol><li><p>bin log</p><ul><li>可以使用 <code>show variables like &#39;%bin%&#39;;</code> 查看bin log相关配置  </li><li>可以使用<code>sql_log_bin</code> 设置bin log的开关，需重启mysql生效</li><li>可以使用<code>binlog_format</code>设定bin log记录模式, 可选值有<strong>statement，row，mixed</strong>  </li><li>bin log是用于point-in-time recovery的，保证服务器可以基于时间点恢复数据，此外binlog还用于主从复制。</li><li>bin log在事务提交时写入</li></ul></li><li><p>redo log<br> InnoDB的数据实际是存储在磁盘中的，但是如果每次读写都需要进行磁盘IO，效率会非常低，所以InnoDB有Buffer Pool(缓存池)机制，缓存池中存放了缓存表和索引数据，避免了读写都需要访问IO，提升了访问速度。当要访问的数据，在缓存池中没有找到，才会去读写IO。<br> Buffer Pool的使用大大提高了数据库的读写效率，但也会造成另外一个问题：如果Mysql服务器宕机，此时，Buffer Pool中的数据还没有写到磁盘，这样数据的持久性无法保证。<br> redo log被用来解决此问题，以保证数据持久性:在InnoDB中，未写入磁盘中<strong>页(Page)**叫做</strong>脏页**，redo log的作用就是记录脏页中的数据，在mysql宕机恢复后，一个事务是否持久化是根据redo log的刷盘情况决定的。如果一个事务的redo log已经全部刷入磁盘，那么这个事务就是有效的，也会被刷入磁盘(持久化)。<br> 为什么需要redo log:</p><ul><li><strong>刷脏</strong>是随机IO，因为每次修改的数据位置随机，但写redo log是追加操作，属于顺序IO。</li><li>在InnoDB中，把<strong>脏页</strong>刷入磁盘叫做<strong>刷脏</strong>，<strong>刷脏</strong>的最小单位是<strong>页</strong>，即就算当前<strong>页</strong>中只有一行数据有修改，也需要更新整<strong>页</strong>。 而redo log中只记录真是需要写入磁盘的数据。</li></ul></li><li><p>undo log<br> 实现事务的原子性的关键，是事务发生回滚时，能够撤销回滚前已经执行的sql语句。InnoDB实现回滚，靠的是undo log:当事务对数据库进行修改时，InnoDB会生成对应的undo log，当事务发生回滚时，会根据undo log中的信息将数据回滚到事务修改前的样子。</p></li></ol><h2 id="事务隔离产生的三大问题-脏读、不可重复读、幻读-虚读"><a href="#事务隔离产生的三大问题-脏读、不可重复读、幻读-虚读" class="headerlink" title="事务隔离产生的三大问题: 脏读、不可重复读、幻读(虚读)"></a>事务隔离产生的三大问题: 脏读、不可重复读、幻读(虚读)</h2><p>这里我们用下面这个表说明, 分别开了两个事务去对这个表进行操作：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from test;</span><br><span class="line">+<span class="comment">----+------------+----------+</span></span><br><span class="line">| id | username   | password |</span><br><span class="line">+<span class="comment">----+------------+----------+</span></span><br><span class="line">|  1 | highphone1 | 123456   |</span><br><span class="line">|  2 | lisi       | 1234     |</span><br><span class="line">|  3 | highphone1 | 1234     |</span><br><span class="line">|  4 | highphone  | 123456   |</span><br><span class="line">+<span class="comment">----+------------+----------+</span></span><br></pre></td></tr></table></figure><ol><li><p>脏读<br> 一个事务读取到了另一个事务还没提交的修改</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td></td><td>begin;</td></tr><tr><td></td><td>update test set <code>username</code> = ‘test1’ where <code>id</code> = 1;</td></tr><tr><td>select <code>username</code> from test where <code>id</code> =1;如果读取到的username为test1，则出现了脏读</td><td></td></tr><tr><td>commit;</td><td></td></tr></tbody></table></li><li><p>不可重复读<br> 事务A过程中，多次对同一个数据进行读取，事务B在事务A读取过程中，修改或者删除这一个数据，导致事务A在多次查询这个数据得到的结果不一样。</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select <code>username</code> from test where <code>id</code> =1;第一次查询结果为’highphone1’</td><td>begin;</td></tr><tr><td></td><td>update test set <code>username</code> = ‘test1’ where <code>id</code> = 1;</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select <code>username</code> from test where <code>id</code> =1;如果查询结果为’test1’, 则出现了不可重复读</td><td></td></tr></tbody></table></li><li><p>幻读<br> 事务A按照一定条件条件查询出来一些数据，事务B又插入了一些满足事务A查询条件的数据，并提交了。事务A再次按同样条件查询会把事务B新插入的数据查询出来</p><table><thead><tr><th>事务A</th><th>事务B</th></tr></thead><tbody><tr><td>begin;</td><td></td></tr><tr><td>select <code>username</code> from test where <code>id</code> &gt;3;第一次查询结果只有一条，即id = 4那条记录</td><td>begin;</td></tr><tr><td></td><td>insert into test(<code>id</code>,<code>username</code>,<code>password</code>) values(5, ‘test2’,’123456’);</td></tr><tr><td></td><td>commit;</td></tr><tr><td>select <code>username</code> from test where <code>id</code> &gt;3;第二次查询结果如果为两条，即出现了幻读</td><td></td></tr></tbody></table></li></ol><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><ul><li>读未提交(Read Uncommitted)<br>  允许脏读, 也就是可能读取到其他事务未提交的修改。</li><li>读已提交(Read Committed)<br>  只能读取到其他事务已提交的修改。Oracle等多数数据库默认隔离级别。</li><li>可重复读(Repeatable Read)<br>  在同一个事务内的查询都是事务开始时刻一致的。mysql innodb默认的隔离级别。</li><li>串行化(Serializable)<br>  完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul><p>事务隔离级别以及在对应隔离级别下可能产生的问题如下表：</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交(Read Uncommitted)</td><td>可能</td><td>可能</td><td>可能</td></tr><tr><td>读已提交(Read Committed)</td><td>不可能</td><td>可能</td><td>可能</td></tr><tr><td>可重复读(Repeatable Read)</td><td>不可能</td><td>不可能</td><td>可能</td></tr><tr><td>串行化(Serializable)</td><td>不可能</td><td>不可能</td><td>不可能</td></tr></tbody></table><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>在可重复读(RR)的事务隔离级别下，解决了脏读和不可重复读，但是没有解决幻读问题。但是在InnoDB的默认事务隔离级别RR中，是解决了幻读问题的，这里就涉及到了MVCC(多版本并发控制)的知识了，跟InnoDB快照读的实现有关。对于当前读、快照读，undo log的多版本实现，read view的可见性控制等知识，可以从下面几篇文献中继续学习，上面的总结也是基于这几篇文献的：</p><ul><li><a href="https://htchz.cc/3647734067.html">Innodb的快照读实现</a></li><li><a href="https://tech.meituan.com/2014/08/20/innodb-lock.html">Innodb中的事务隔离级别和锁的关系</a></li><li><a href="https://developer.aliyun.com/article/743691">彻底搞懂 MySQL 事务的隔离级别</a></li><li><a href="https://developer.aliyun.com/article/560506">MySQL · 源码分析 · InnoDB的read view，回滚段和purge过程简介</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础(二)</title>
      <link href="/8baabe1.html"/>
      <url>/8baabe1.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据操作语言-DML"><a href="#数据操作语言-DML" class="headerlink" title="数据操作语言(DML)"></a>数据操作语言(DML)</h2><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><blockquote><p>语法: insert into <code>table_name</code>(field1, field2, …) values(value1, value2,….),(value1,value2,…)</p></blockquote><h4 id="往数据表test中插入一条数据："><a href="#往数据表test中插入一条数据：" class="headerlink" title="往数据表test中插入一条数据："></a>往数据表test中插入一条数据：</h4><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建数据表</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> <span class="string">`test`</span>(</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span> <span class="keyword">unsigned</span> auto_increment,</span><br><span class="line">    <span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">50</span>),</span><br><span class="line">    <span class="string">`password`</span> <span class="built_in">varchar</span>(<span class="number">100</span>),</span><br><span class="line">    primary <span class="keyword">key</span>(<span class="string">`id`</span>)</span><br><span class="line">)<span class="keyword">engine</span>=<span class="keyword">InnoDb</span> <span class="keyword">default</span> <span class="keyword">charset</span>=utf8;</span><br><span class="line"><span class="comment">#插入一条数据,由于id是主键，切自动增长，我们在插入数据的时候并不需要显示指明主键。 </span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test`</span>(<span class="string">`username`</span>,<span class="string">`password`</span>) <span class="keyword">values</span>(<span class="string">&#x27;zhangsan&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br><span class="line">       </span><br></pre></td></tr></table></figure></code></pre><p><img src="../images/2020-12-28-22-37-12.png"></p><h4 id="往数据表中插入多条数据"><a href="#往数据表中插入多条数据" class="headerlink" title="往数据表中插入多条数据"></a>往数据表中插入多条数据</h4><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">#插入多条数据</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="string">`test`</span>(<span class="string">`username`</span>,<span class="string">`password`</span>) <span class="keyword">values</span></span><br><span class="line">(<span class="string">&#x27;lisi&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;wangwu&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>),</span><br><span class="line">(<span class="string">&#x27;tianqi&#x27;</span>, <span class="string">&#x27;123456&#x27;</span>);</span><br></pre></td></tr></table></figure></code></pre><p><img src="../images/2020-12-28-22-41-34.png"></p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>语法中的的(field1, field2, …)可以不写，但不写此项需要在values中写全表中的所有字段的值,所以写insert语句的时候，建议field与value要一一对应</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#insert into `test` values(&#x27;zhaoliu&#x27;, &#x27;1234&#x27;);</span></span><br></pre></td></tr></table></figure><p><img src="../images/2020-12-28-22-45-12.png"></p><h3 id="修改数据"><a href="#修改数据" class="headerlink" title="修改数据"></a>修改数据</h3><blockquote><p>语法:update <code>table_name</code> set <code>field_name</code> where 条件</p></blockquote><h4 id="把id-gt-3的用户名设置成highphone"><a href="#把id-gt-3的用户名设置成highphone" class="headerlink" title="把id &gt; 3的用户名设置成highphone"></a>把id &gt; 3的用户名设置成highphone</h4><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> <span class="string">`test`</span> <span class="keyword">set</span> <span class="string">`username`</span>=<span class="string">&#x27;highphone&#x27;</span> <span class="keyword">where</span> <span class="string">`id`</span> &gt; <span class="number">3</span>;</span><br></pre></td></tr></table></figure></code></pre><p><img src="../images/2020-12-28-22-54-10.png"></p><h4 id="双重条件-and-和-or"><a href="#双重条件-and-和-or" class="headerlink" title="双重条件 and 和 or"></a>双重条件 and 和 or</h4><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把id &gt; 2和id &lt; 3的密码修改成1234</span></span><br><span class="line"><span class="keyword">update</span> <span class="string">`test`</span> <span class="keyword">set</span> <span class="string">`password`</span>=<span class="string">&#x27;1234&#x27;</span> <span class="keyword">where</span> <span class="string">`id`</span> &gt; <span class="number">1</span> <span class="keyword">and</span> <span class="string">`id`</span> &lt; <span class="number">3</span>;</span><br><span class="line"><span class="comment"># 把id = 1 或id = 3的记录的用户名修改成highphone1</span></span><br><span class="line"><span class="keyword">update</span> <span class="string">`test`</span> <span class="keyword">set</span> <span class="string">`username`</span>=<span class="string">&#x27;highphone1&#x27;</span> <span class="keyword">where</span> <span class="string">`id`</span> = <span class="number">1</span> <span class="keyword">or</span> <span class="string">`id`</span> = <span class="number">3</span> ;</span><br></pre></td></tr></table></figure></code></pre><p><img src="../images/2020-12-28-23-15-12.png"></p><p><img src="../images/2020-12-28-23-17-40.png"></p><h4 id="where子句"><a href="#where子句" class="headerlink" title="where子句"></a>where子句</h4><p>where子句操作符返回布尔值</p><table><thead><tr><th>含义</th><th>操作符</th><th>示例</th><th>结果</th></tr></thead><tbody><tr><td>等于</td><td>=</td><td>1=2</td><td>false</td></tr><tr><td>不等于</td><td>&lt;&gt;或!=</td><td>1&lt;&gt;2</td><td>true</td></tr><tr><td>大于</td><td>&gt;</td><td>1 &gt; 2</td><td>false</td></tr><tr><td>小于</td><td>&lt;</td><td>1 &lt; 2</td><td>true</td></tr><tr><td>大于等于</td><td>&gt;=</td><td>1 &gt;=2</td><td>false</td></tr><tr><td>小于等于</td><td>&lt;=</td><td>1 &lt;=2</td><td>true</td></tr><tr><td>在..范围</td><td>between…and</td><td>[2, 5]</td><td>闭区间</td></tr><tr><td>且</td><td>and</td><td>5 &gt; 2 and 2 &gt; 1</td><td>true</td></tr><tr><td>或</td><td>or</td><td>5 &gt; 2 or 1 &gt; 2</td><td>true</td></tr></tbody></table><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><blockquote><p>语法： delete from <code>table_name</code> [where 条件]</p></blockquote><h4 id="delete命令"><a href="#delete命令" class="headerlink" title="delete命令"></a>delete命令</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--删除全部数据(不建议使用)</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="string">`test`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--删除指定数据,条件中的where子句与update语句中类似</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> <span class="string">`test`</span> <span class="keyword">where</span> <span class="string">`id`</span> =<span class="number">4</span></span><br></pre></td></tr></table></figure><h4 id="truncate命令"><a href="#truncate命令" class="headerlink" title="truncate命令"></a>truncate命令</h4><p>作用: 完全清空一个数据库表，表的结构和索引不会变</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">truncate</span> <span class="string">`test`</span></span><br></pre></td></tr></table></figure><h4 id="delete和truncate的区别"><a href="#delete和truncate的区别" class="headerlink" title="delete和truncate的区别"></a>delete和truncate的区别</h4><ul><li>相同点：都能删除整表数据，都不会删除表结构</li><li>不同点：<ul><li>truncate 可以重新设置自增列，计数器会归零，delete 不会重置自增列的计算器(innodb中重启数据库会重置)</li><li>truncate 不会影响事务</li></ul></li></ul><h2 id="数据查询语言-DQL"><a href="#数据查询语言-DQL" class="headerlink" title="数据查询语言(DQL)"></a>数据查询语言(DQL)</h2><h3 id="Select语法："><a href="#Select语法：" class="headerlink" title="Select语法："></a>Select语法：</h3><pre><code><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> [<span class="keyword">ALL</span>| <span class="keyword">DISTINCT</span>]   </span><br><span class="line">&#123;[tablename.]* | [tablename.]field1 [<span class="keyword">AS</span> <span class="keyword">alias</span>], [tablename.]field2 [<span class="keyword">AS</span> <span class="keyword">alias</span>],....&#125;   </span><br><span class="line"><span class="keyword">FROM</span> tablename [<span class="keyword">AS</span> <span class="keyword">alias</span>] </span><br><span class="line">[<span class="keyword">LEFT</span> | <span class="keyword">RIGHT</span> | <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tablename <span class="keyword">AS</span> <span class="keyword">alias</span>] </span><br><span class="line">[<span class="keyword">WHERE</span> 条件]    </span><br><span class="line">[<span class="keyword">GROUP</span> <span class="keyword">BY</span> fieldname]    </span><br><span class="line">[<span class="keyword">HAVING</span> 条件] </span><br><span class="line">[<span class="keyword">ORDER</span> <span class="keyword">BY</span> fieldName ,... <span class="keyword">ASC</span>|<span class="keyword">DESC</span>] </span><br><span class="line">[<span class="keyword">LIMIT</span> startIndex pageSize] </span><br></pre></td></tr></table></figure></code></pre><ul><li>Select [ALL| DISTINCT]<br>  ALL代表查询结果全部显示出来(默认)， DISTINCT代表查询结果去重</li><li>{[tablename.]* | [tablename.]field1 [AS alias], [tablename.]field2 [AS alias],….}<br>  中括号内为可选内容，*｜tablename.*代表查询全部列。field1或者tablename.field1表示查询指定列，多个filed中用,分隔开，as子句为指定列其别名(可选，如指定，查询结果中显示的就是别名)</li><li>FROM tablename [AS alias]<br>  查询指定数据表，as子句为指定数据表别名，可用别名代替数据表名</li><li>[LEFT | RIGHT | INNER JOIN tablename AS alias]<br>  连表查询，可选左连接、右连接、内连接</li><li>[WHERE 条件]<br>  where子句，查询需要满足此条件的数据</li><li>[GROUP BY fieldname]<br>  查询结果按照指定列分组</li><li>[HAVING 条件]<br>  分组查询结果上再根据having条件过滤</li><li>[ORDER BY fieldName ,… ASC|DESC]<br>  根据指定一个或者多个字段排序 ASC 升序  DESC 降序</li><li>[LIMIT startIndex pageSize]<br>  指定分页查询，参数是当前页起始位置和当前页行数。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaWeb基础(一)</title>
      <link href="/e303343.html"/>
      <url>/e303343.html</url>
      
        <content type="html"><![CDATA[<h2 id="JavaWeb是什么"><a href="#JavaWeb是什么" class="headerlink" title="JavaWeb是什么"></a>JavaWeb是什么</h2><blockquote><p>用Java技术来解决相关web互联网领域的技术栈统称为JavaWeb。<br>一个web应用程序由多部分组成，主要分为静态web资源和动态web资源：</p></blockquote><ul><li>html页面 、css(层叠样式表)、 js</li><li>servlet、jsp(JavaServer Page, 本质是servlet)</li><li>java程序</li><li>jar包依赖</li><li>配置文件</li></ul><h2 id="请求和响应"><a href="#请求和响应" class="headerlink" title="请求和响应"></a>请求和响应</h2><p>在B/S模式下，浏览器与服务器通过http进行通信，如下是web应用中浏览器与服务器交互的简要过程<br><img src="../images/2020-12-25-22-32-46.png"></p><h2 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h2><blockquote><p>狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。Servlet运行于支持Java的应用服务器中。从原理上讲，Servlet可以响应任何类型的请求，但绝大多数情况下Servlet只用来扩展基于HTTP协议的Web服务器。</p></blockquote><ol><li><p>在JavaWeb中，我们通过实现javax.Servlet接口来处理http请求，并返回http响应,如下Servlet接口源码中只约定了5个方法，主要逻辑在service方法里面</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> javax.servlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig var1)</span> <span class="keyword">throws</span> ServletException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ServletConfig <span class="title">getServletConfig</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getServletInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Servlet的实现类GenericServlet也没有实现service方法：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest var1, ServletResponse var2)</span> <span class="keyword">throws</span> ServletException, IOException</span>;</span><br></pre></td></tr></table></figure></li><li><p>我们常用HttpServlet这个类来处理http请求，HttpServlet就继承了GenericServlet，并实现了service方法,其中根据请求方法的不同，分别调用了不同的处理方法，比较常见的就是对应GET请求的doGet()和POST请求的doPost(),并在doGet()或者doPost()方法中处理请求，并封装响应信息。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">long</span> lastModified;</span><br><span class="line">    <span class="keyword">if</span> (method.equals(<span class="string">&quot;GET&quot;</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(<span class="string">&quot;If-Modified-Since&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) &#123;</span><br><span class="line">                <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resp.setStatus(<span class="number">304</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;HEAD&quot;</span>)) &#123;</span><br><span class="line">        lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">        <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">        <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;POST&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;PUT&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;DELETE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;OPTIONS&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">&quot;TRACE&quot;</span>)) &#123;</span><br><span class="line">        <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">&quot;http.method_not_implemented&quot;</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="一个简单的Servlet例子"><a href="#一个简单的Servlet例子" class="headerlink" title="一个简单的Servlet例子"></a>一个简单的Servlet例子</h2><ol><li>编写一个简单的Java类，继承HttpServlet类，并重写其中的doGet()和doPost()： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        doPost(req, resp);<span class="comment">//无论是get还是post请求，都调用doPost处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//this.getInitParameter(); //初始化参数</span></span><br><span class="line">        ServletConfig config = <span class="keyword">this</span>.getServletConfig();<span class="comment">//servlet配置</span></span><br><span class="line">        ServletContext servletContext = <span class="keyword">this</span>.getServletContext();<span class="comment">//servlet上下文</span></span><br><span class="line"></span><br><span class="line">        resp.setContentType(<span class="string">&quot;text/html&quot;</span>); <span class="comment">//设置响应的内容</span></span><br><span class="line">        resp.setCharacterEncoding(<span class="string">&quot;utf-8&quot;</span>);<span class="comment">//设置响应编码格式</span></span><br><span class="line">        PrintWriter writer = resp.getWriter();<span class="comment">//输出内容到响应信息</span></span><br><span class="line">        writer.print(<span class="string">&quot;&lt;h1&gt;highPhone啊&lt;/h1&gt;&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>在web.xml中注册此Servlet并定义此Servlet处理的请求url格式： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>xyz.highphone.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>*.highphone<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote></blockquote></li></ol><ul><li>servlet-name中的名字是唯一确定的，不能重复</li><li>一个servlet可以对应多个servlet-mapping</li><li>*是url通配符，表明此Servlet会处理url为.highphone结尾的所有请求，也可以精确为/highphone，优先匹配精确url，再匹配通配符</li></ul><ol start="3"><li>启动项目，进行测试<br><img src="../images/2020-12-25-23-02-13.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识动态规划</title>
      <link href="/a3750514.html"/>
      <url>/a3750514.html</url>
      
        <content type="html"><![CDATA[<h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><blockquote><p>先来一波维基百科定义:<br>    动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。</p></blockquote><pre><code>动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。</code></pre><h2 id="从斐波那契数列认识动态规划"><a href="#从斐波那契数列认识动态规划" class="headerlink" title="从斐波那契数列认识动态规划"></a>从斐波那契数列认识动态规划</h2><h3 id="我们先来复习下大学时候题目："><a href="#我们先来复习下大学时候题目：" class="headerlink" title="我们先来复习下大学时候题目："></a>我们先来复习下大学时候题目：</h3><pre><code>    求解对于输入整数n，求解斐波那契数列中第n个数字。</code></pre><h3 id="使用递归思路求解："><a href="#使用递归思路求解：" class="headerlink" title="使用递归思路求解："></a>使用递归思路求解：</h3><pre><code>    我们可以用f(n)表示斐波那契数列第n个数字，则有    1. 对于 n &gt;= 2的输入，求解斐波那契数列第n个数字通过第n-1个数字+第n-2个数字得到，即f(n) = f(n -1) + f(n -2);    2. 相应的，第n-1个数字即为 f(n-1) = f(n - 2) + f(n -3)    .....    3. 如此递归下去，而f(0) = 0, f(1) = 1，这就是递归终止条件。    <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DpTest1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.print(fibTest1(i) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibTest1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> fibTest1(n-<span class="number">1</span>) + fibTest1(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>    如上是同个递归求0 - 20的斐波那契数列的代码，看起来还不错，问题似乎解决了。</code></pre><p><img src="../images/2020-12-20-21-29-12.png"><br>        递归思路简单清晰，但是其在空间和效率上的缺陷也特别明显，这种缺陷随着数据规模的增大，表现得越来越明显：<br>        我们对代码进行稍微的改写，分别计算第10、20、30、40、50个斐波那契数，并计算求解时花费的时间及递归调用次数：<br>            <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DpTest1</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> fibCnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt;= <span class="number">50</span> ; i+= <span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                fibCnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">                System.out.println(fibTest1(i));</span><br><span class="line">                <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">&quot;求解第&quot;</span> + i + <span class="string">&quot;个斐波那契数用时：&quot;</span> + (end -start) / <span class="number">1000.0</span> + <span class="string">&quot;s. 递归方法调用次数为：&quot;</span> + fibCnt + <span class="string">&quot;次&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibTest1</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            fibCnt ++;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> fibTest1(n-<span class="number">1</span>) + fibTest1(n - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br></pre></td></tr></table></figure><br>        通过运行结果可以看到，对于数据规模为50的一个递归求解，所需要的用时已经是我们难以接受的了，同时看递归调用的次数也看出，对空间的花费也是极大：<br><img src="../images/2020-12-20-23-55-17.png"></p><h3 id="使用记忆化搜索对递归进行优化"><a href="#使用记忆化搜索对递归进行优化" class="headerlink" title="使用记忆化搜索对递归进行优化"></a>使用记忆化搜索对递归进行优化</h3><pre><code>对于在时间和空间上都基本呈指数增长的递归算法求解斐波那契数，我们能否对其进行优化？答案是肯定的。    1. 我们用n=5来分析下，递归算法之所以如此费时和费空间的原因</code></pre><p><img src="../images/2020-12-21-00-40-18.png"><br>            从图中可以看出，我们计算f(5),需要计算1次f(4), 2次f(3), 3次f(2),还需要调用5次f(1)和3次f(0), 其中，有大量重复的调用和计算，因此浪费了大量的时间和空间。<br>        2. 通过1的分析，我们尝试优化1中存在的重复计算和调用<br>            &gt; 定义一个长度为n + 1的int数组memory(当数据规模非常大时，可以替换成long)，memory[i]保存第i个斐波那契数。<br>            &gt; 每次递归调用f[i]时，先检查memory[i]是否已经有计算结果，如果有，读取memory[i]的值返回<br>            &gt; 如果memory[i]中还没有保存有f[i]的值，递归调用f[i -1] + f[i -2]计算结果，然后保存到memory[i]中，然后返回memory[i].</p><pre><code>    改进后的代码如下        <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DpTest1</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> fibCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt;= <span class="number">50</span> ; i+= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//定义memory，并把每个元素赋予初值为 -1；</span></span><br><span class="line">            <span class="keyword">long</span>[] memory = <span class="keyword">new</span> <span class="keyword">long</span>[i + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                memory[j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            fibCnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            System.out.println(fibTest1(i, memory));</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;求解第&quot;</span> + i + <span class="string">&quot;个斐波那契数用时：&quot;</span> + (end -start) / <span class="number">1000.0</span> + <span class="string">&quot;s. 递归方法调用次数为：&quot;</span> + fibCnt + <span class="string">&quot;次&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fibTest1</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">long</span>[] memory)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memory[n] != -<span class="number">1</span>)<span class="comment">//做递归调用之前，先判断当前n是否已计算过</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> memory[n];</span><br><span class="line">        &#125;</span><br><span class="line">        fibCnt ++;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            memory[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">return</span> memory[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            memory[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> memory[<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            memory[n] = fibTest1(n-<span class="number">1</span>, memory) + fibTest1(n - <span class="number">2</span>, memory);</span><br><span class="line">            <span class="keyword">return</span> memory[n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><blockquote><p>可以看到，现在我们计算斐波那契数已经非常快了，同时调用递归方法的次数也变成了memory数组的长度了，即n+1，此优化递归算法的方法叫做 <strong>记忆化搜索</strong>。<br><img src="../images/2020-12-21-21-17-43.png"></p></blockquote><h2 id="初识动态规划"><a href="#初识动态规划" class="headerlink" title="初识动态规划"></a>初识动态规划</h2><blockquote><p>上述的记忆搜索算法优化后的递归方法，对于求解斐波那契数来说，无论是从时间复杂度还是从空间复杂度来说，都已经是一个很好的算法了，但是我们是否可以再用更加优秀的算法来求解呢，答案就是动态规划法。将原问题拆解成若干自问题，同时保存子问题的答案，使得每个子问题只求解一次，最终获得原问题的答案，这就是动态规划。</p></blockquote><ul><li>回到求解斐波那契数的问题，我们通过递归算法进行求解的时候，会产生很多需要重复计算和调用的第i个斐波那契数，这些重叠的斐波那契数就是这个原问题的重叠子问题。</li><li>为了解决重叠子问题，我们在上面使用了记忆化搜索方法，从n 到 0，我们自顶向下地计算f(i)的值，并保存到memory数组中。</li><li>如果我们用自底向上的方法去解决重叠子问题的话，即定义一个dp数组，dp数组中第i项记录第i个斐波那契数，我们让dp[0] = 0,dp[1] =1,从第2项开始，dp[i] = dp[i-1] + dp[i-2],从 2到 n遍历完成后，dp[n] 即得到了第n个斐波那契数，这就是这道题的动态规划思路<br><img src="../images/2020-12-21-22-37-54.png"></li></ul><h3 id="动态规划求解斐波那契数"><a href="#动态规划求解斐波那契数" class="headerlink" title="动态规划求解斐波那契数"></a>动态规划求解斐波那契数</h3><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DpTest2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &lt;= <span class="number">40</span> ; i+= <span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">            System.out.println(fibDpTest(i));</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.out.println(<span class="string">&quot;动态规划求解第&quot;</span> + i + <span class="string">&quot;个斐波那契数用时：&quot;</span> + (end -start) / <span class="number">1000.0</span> + <span class="string">&quot;s.&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fibDpTest</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> len = n +<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i] = dp[i-<span class="number">1</span>] + dp[i-<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><img src="../images/2020-12-21-22-33-05.png"></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程基础(一)</title>
      <link href="/241f90c5.html"/>
      <url>/241f90c5.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><pre><code>进程:</code></pre><p>　　    应用程序的执行实例,有独立内存空间和系统资源</p><pre><code>线程:</code></pre><p>　　    cpu调度和分派的基本单位,进程中执行运算最小的单位,可完成一个独立顺序控制流程</p><pre><code>多线程:　　 在一个进程中同时运行了多个线程,完成不同的工作    多个线程交替占用cpu资源,而非真正并行执行    好处:　　　　充分利用cpu资源　　　　简化编程模型　　　　带来良好用户体验</code></pre><h2 id="创建线程的三种方式"><a href="#创建线程的三种方式" class="headerlink" title="创建线程的三种方式"></a>创建线程的三种方式</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><pre><code>1. 编写自己的线程类，使用extends关键字继承Thread类2. 重写继承自Thread类的run方法，自定义自己的线程工作内容3. 创建自定义线程对象，调用start()方法启动线程<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest1 thread1 = <span class="keyword">new</span> ThreadTest1(<span class="string">&quot;线程一&quot;</span>);</span><br><span class="line">        ThreadTest1 thread2 = <span class="keyword">new</span> ThreadTest1(<span class="string">&quot;线程二&quot;</span>);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ThreadTest1</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;<span class="comment">//线程每秒打印i,从1到10</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在打印：&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><p><img src="../images/2020-12-20-01-46-28.png"></p><h3 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h3><pre><code>1. 编写自己的线程类，使用implements关键字实现Runnable接口2. 重写Runnable接口的run方法，自定义线程工作内容3. 创建自定义线程对象，通过new Thread().start()传入自定线程对象的方式启动自定义线程(静态代理)。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest2 thread1 = <span class="keyword">new</span> ThreadTest2();</span><br><span class="line">        ThreadTest2 thread2 = <span class="keyword">new</span> ThreadTest2();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread1, <span class="string">&quot;线程一&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread2, <span class="string">&quot;线程二&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在打印&quot;</span> + i);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>Runnable接口其实是一个函数式接口，通过实现Runnable接口方式创建线程，还可以使用Lambda表达式创建自定义线程对象，这样可以让代码更加简洁：</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在打印&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;线程一&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h3><ol><li><p>编写自定义线程类，使用implements实现Callable<V> 接口</V></p></li><li><p>重写Callable接口的call方法，自定义线程工作内容，根据实际情况确定线程方法体的返回值，返回值就是Callable<V> 中的泛型。</V></p></li><li><p>创建ExecutorService,通过sumbit()启动线程，submit()返回方法体返回值类型一致的Future<V>,可以获得线程执行完的返回值。</V></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest4</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Boolean</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService service = Executors.newSingleThreadExecutor();</span><br><span class="line">        Future&lt;Boolean&gt; future = service.submit(<span class="keyword">new</span> ThreadTest4());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Boolean callResult = future.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;线程执行结果返回是&quot;</span> + callResult);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">finally</span> &#123;</span><br><span class="line">            service.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在打印&quot;</span> + i);</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/2020-12-20-13-48-22.png"></p><blockquote><p>虽然是实现 Callable ，但是在 Executor 实际运行时，会将 Runnable 的实例或 Callable 的实例转化为 RunnableFuture 的实例，而 RunnableFuture 继承了 Runnable 和 Future 接口。另外，相比实现Runnable接口，实现Callable接口有以下优点:</p></blockquote></li></ol><ul><li>Callable 可以在任务结束的时候提供一个返回值，Runnable 无法提供这个功能</li><li>Callable 的 call 方法分可以抛出异常，而 Runnable 的 run 方法不能抛出异常。</li></ul></li></ul><h2 id="线程状态及Thread常用方法"><a href="#线程状态及Thread常用方法" class="headerlink" title="线程状态及Thread常用方法"></a>线程状态及Thread常用方法</h2><h3 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h3><p><img src="../images/2020-12-20-14-16-48.png"></p><ul><li>新生状态状态(new)<br>  Thread t = new Thread(),线程对象一旦创建就进入到新生状态</li><li>就绪状态(Runnable)<br>  可执行状态，当调用start()方法启动线程后，线程进入就绪状态，可以被CPU调度执行，但不意味着会立即调度</li><li>运行状态(Running)<br>  线程被CPU调度，获得CPU资源后进入运行状态，执行run()方法里的线程体代码块。</li><li>阻塞状态(Blocked)<br>  当调用sleep(),wait()或同步锁定等，线程需要等待唤醒或者需要等待别的线程释放锁定资源时，线程进入阻塞状态，就是代码块不往下执行，等待阻塞时间解除后，重新进入就绪状态，等待CPU调度执行。</li><li>死亡状态(Dead)<br>  线程发生异常或者被外部中断，或者线程执行完毕正常结束后，线程进入死亡状态。线程一旦进入死亡状态，就不能够再次启动。</li></ul><h3 id="Thread常用方法"><a href="#Thread常用方法" class="headerlink" title="Thread常用方法"></a>Thread常用方法</h3><ul><li>setPriority(int newPriority)<br>  更改线程优先级，数字越大，优先级越高，但线程优先级并不是绝对的，有可能存在低优先级的线程比高优先级线程先被CPU调度的情况</li><li>static void sleep(long milllis)<br>  在指定毫秒数内让当前线程休眠，休眠结束后重新进入就绪状态等待CPU调度</li><li>void join()<br>  别的线程等待当前线程终止后再执行(插队)</li><li>static void yield()<br>   暂停当前正在执行的线程对象，释放CPU资源，重新进入就绪状态(礼让其他线程)，但yield()礼让不一定会成功，只是让当前执行的线程重新回到就绪状态，和其他线程再次竞争CPU资源，也有可能会再次被CPU调度。</li><li>final void stop()<br>  停止当前线程，但是不建议使用，此方法已被声明为废弃</li><li>void destroy()<br>  销毁线程，同stop()，此方法也被废弃<blockquote><p>要终止一个线程，我们可以通过自定义标志位，并自行声明stop()供外界调用以终止线程</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ThreadTest2 thread1 = <span class="keyword">new</span> ThreadTest2();</span><br><span class="line">        ThreadTest2 thread2 = <span class="keyword">new</span> ThreadTest2();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread1, <span class="string">&quot;线程一&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(thread2, <span class="string">&quot;线程二&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;正在打印&quot;</span> + i);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Lambda表达式</title>
      <link href="/bbcf5ff7.html"/>
      <url>/bbcf5ff7.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>lambda表达式是JDK1.8的新特性之一，使用lambda表达式可以缩减大量的匿名内部类的使用，避免了大量重复冗余的编码，使代码变得简洁优雅，用于多线程、集合操作中可以极大的简化代码。表达式结构如下：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(params) -&gt; expression </span><br><span class="line">(params) -&gt; statement</span><br><span class="line">(para,s) -&gt; &#123;statements&#125;</span><br></pre></td></tr></table></figure><p>如上 <strong>()</strong> 是参数列表 <strong>{}</strong> 是方法体 <strong>-&gt;</strong> 是lambda运算符</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><blockquote><p>定义：函数式接口(Functional Interface)就是一个有且仅有一个抽象方法，但是可以有多个非抽象方法的接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lambda表达式的推导过程"><a href="#lambda表达式的推导过程" class="headerlink" title="lambda表达式的推导过程"></a>lambda表达式的推导过程</h2><ol><li><p>在最初的接口中，我们要是实现接口方法，需要编写接口的实现类，再通过实现类重写方法来实现，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyFunctionInterface1 lambda1 = <span class="keyword">new</span> HelloLambda();</span><br><span class="line">    lambda1.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HelloLambda</span> <span class="keyword">implements</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello Lambda.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果接口的实现类是外部类，实现起来比较麻烦，一种改进的方法是把函数式接口的实现写到静态内部类中，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLambda2</span> <span class="keyword">implements</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class">  </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Hello Lambda2.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyFunctionInterface1 lambda2 = <span class="keyword">new</span> HelloLambda2();</span><br><span class="line">      lambda2.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再进一步简化，可以使用局部内部类实现函数式接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HelloLambda3</span> <span class="keyword">implements</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello Lambda3.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    MyFunctionInterface1 lambda3 = <span class="keyword">new</span> HelloLambda3();</span><br><span class="line">    lambda3.sayHello();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>再进一步，可以使用匿名内部类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyFunctionInterface1 lambda4 = <span class="keyword">new</span> MyFunctionInterface1() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello Lambda4.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    lambda4.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在匿名内部类的基础上再进一步简化，就是我们的Lambda表达式了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      MyFunctionInterface1 lambda5 = () -&gt;&#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;Hello Lambda5.&quot;</span>);</span><br><span class="line">      &#125;;</span><br><span class="line">      lambda5.sayHello();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface1</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="Lambda表达式使用及简化"><a href="#Lambda表达式使用及简化" class="headerlink" title="Lambda表达式使用及简化"></a>Lambda表达式使用及简化</h2><ol><li><p>lambda表达式可以带参数及带参数类型，如下有个函数式接口定义了一个两个int类型参数及int类型返回的接口方法，我们用lambda表达式实现的calc方法作用是返回x+1+y的结果；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyFunctionInterface2 lambda2 = (<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; &#123;</span><br><span class="line">        x++;</span><br><span class="line">        <span class="keyword">return</span> x+y;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(lambda2.calc(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/2020-12-19-22-07-20.png"></p></li><li><p>如上例子的lambda表达式中，有如下简化规则</p><ul><li>参数类型可以省略，lambda表达式会自动按顺序匹配参数类型<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  MyFunctionInterface2 lambda2 = (x, y) -&gt; &#123;</span><br><span class="line">      x++;</span><br><span class="line">      <span class="keyword">return</span> x+y;</span><br><span class="line">  &#125;;</span><br><span class="line">  System.out.println(lambda2.calc(<span class="number">10</span>,<span class="number">5</span>));</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果函数式接口中接口方法的参数只有一个，则小括号可以省略<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyFunctionInterface2 lambda2 = x -&gt; &#123;</span><br><span class="line">        x += <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">return</span> x/<span class="number">5</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    System.out.println(lambda2.calc(<span class="number">10</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果lambda表达式实现的方法体中，只有一句表达式，或者一行语句，花括号也可以省略：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyFunctionInterface2 lambda2 = x -&gt; x/<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(lambda2.calc(<span class="number">10</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MyFunctionInterface2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//无参接口方法</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2>一开始接触lambda表达式可能会看不习惯，但是就和三元表达式一样，使用lambda表达式有时候可以让我们的代码更加简洁和优雅。</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Lambda表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode49-字母异位词分组</title>
      <link href="/29fb013c.html"/>
      <url>/29fb013c.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是leetcode题库的第49题 - <a href="https://leetcode-cn.com/problems/group-anagrams/">字母异位词分组</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解答前分析"><a href="#解答前分析" class="headerlink" title="解答前分析"></a>解答前分析</h3><pre><code>根据题目意思：</code></pre><ul><li>输入的数据全是小写字母，所以这道题目不必考虑大小写问题</li><li>不用考虑输出的顺序</li><li>输入为空的情况返回空的List</li></ul><h3 id="解题分析"><a href="#解题分析" class="headerlink" title="解题分析"></a>解题分析</h3><ol><li>异位词，可以看作是同一个字符串中字符的不同组合，所以，当所有异位词中的字符按照字母顺序重新排序后，肯定是相同的。</li><li>所有的异位词最终需要放到同一个数组中返回，考虑用ArrayList去存放同一组异位词</li><li>利用HashMap中key的唯一性，把2中的同类异位词放到HashMap中，key就是1中提到的字符数组排序后的值，这里注意要用String(不可变)做key，而非这个排序的字符数组</li><li>遍历入参的字符串数组，对于每个字符串元素，利用一个字符数组排序后，得到这个字符串的key，再去3中的HashMap中寻找，如果有找到这个key，证明前面已经有这个类别的异位词了，我们就把新的异位词添加到后面；如果没找到这个key，就新建一个ArrayList去存放这个异位词。</li><li>遍历完成后，我们就得到了一个分类好的HashMap，key是各个类别的异位词按字母顺序排列的字符串，value是这个类别的异位词数组，由于我们只关注value，所以只需要把value返回即可。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; groupString = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(strs != <span class="keyword">null</span> &amp;&amp; strs.length &gt; <span class="number">0</span>)<span class="comment">//考虑空值输入</span></span><br><span class="line">        &#123;</span><br><span class="line">            Map&lt;String, List&lt;String&gt;&gt; strMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">                <span class="keyword">char</span>[] str = strs[i].toCharArray();<span class="comment">//每个元素所属异位词的key</span></span><br><span class="line">                Arrays.sort(str);<span class="comment">//对当前元素的字符数组进行排序</span></span><br><span class="line">                String strKey = String.valueOf(str);</span><br><span class="line">                List&lt;String&gt; stringList = strMap.containsKey(strKey) ? strMap.get(strKey) : <span class="keyword">new</span> ArrayList&lt;&gt;();<span class="comment">//得到当前元素所属分类</span></span><br><span class="line">                stringList.add(strs[i]);</span><br><span class="line">                strMap.put(strKey, stringList);</span><br><span class="line">            &#125;</span><br><span class="line">            groupString = <span class="keyword">new</span> ArrayList&lt;&gt;(strMap.values());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> groupString;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解答结果"><a href="#解答结果" class="headerlink" title="解答结果"></a>解答结果</h3><p><img src="../images/2020-12-15-00-08-19.png"></p><h3 id="更多题解"><a href="#更多题解" class="headerlink" title="更多题解"></a><a href="https://leetcode-cn.com/problems/group-anagrams/solution/">更多题解</a></h3>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql基础(一)</title>
      <link href="/8e40d0ad.html"/>
      <url>/8e40d0ad.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>SQL关键字不区分大小写</p></blockquote><h2 id="数据库的创建、使用、查看、删除"><a href="#数据库的创建、使用、查看、删除" class="headerlink" title="数据库的创建、使用、查看、删除"></a>数据库的创建、使用、查看、删除</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">not</span>  <span class="keyword">exists</span> db1 <span class="comment">--if not exists是可选的，它是为了在创建数据库前检查需要创建的数据库是否存在，如果存在就不会再执行创建</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="string">`db1`</span>     <span class="comment">--反引号是可选的，当db名称与mysql关键字一致的时候就必须加上</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">databases</span> <span class="comment">--查看所有数据库</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> <span class="keyword">if</span> <span class="keyword">exists</span> db1  <span class="comment">--if exists也是可选的，它是为了在删除数据库前检查需要删除的数据库是否存在，如果不存在就不会再执行删除</span></span><br></pre></td></tr></table></figure><p> <img src="../images/2020-12-13-17-11-33.png"></p><h2 id="数据表的创建、删除、修改、查看"><a href="#数据表的创建、删除、修改、查看" class="headerlink" title="数据表的创建、删除、修改、查看"></a>数据表的创建、删除、修改、查看</h2><h3 id="mysql数据类型"><a href="#mysql数据类型" class="headerlink" title="mysql数据类型"></a>mysql数据类型</h3><pre><code>1. 数值    tinyint     十分小的整数            1个字节    smallint    较小的整数              2个字节    mediumint   中等大小的整数           3个字节    **int       标准的整数              4个字节(常用)**    bigint      较大的整数              8个字节    float       浮点数                 4个字节(浮点数存在精度问题)    double      浮点数                 8个字节(浮点数存在精度问题)    decimal     字符串形式的浮点数       2. 字符串    char        固定大小的字符串         0-255    **varchar   可变字符串              0-65535(常用)**    tinytext    微型文本                0-2^8-1    text        文本串                  0-2^16-13. 时间日期    date        日期                YYYY-MM-DD    time        时间                HH:mm:ss    **datetime  日期+时间           YYYY-MM-DD HH:mm:ss(常用)**    **timestamp 时间戳              1970-01-01到当前时间的毫秒数**    year        年</code></pre><h3 id="mysql字段属性"><a href="#mysql字段属性" class="headerlink" title="mysql字段属性"></a>mysql字段属性</h3><pre><code>1. Unsigned    无符号整数，声明该列不能是负数，数值类型可用2. zerofill    零填充，不足位数的，使用0填充，数值类型可用。  --int(3)   1 ---&gt;0013. auto_increment    自增，用于主键的自动增长(默认是+1，可以指定)，数值类型可用,**非主键字段设置自增会报错**4. not null    设置not null后，不能给该字段插入null数据5. default    设置默认值，插入数据时没有给该字段赋值，则显示为默认值</code></pre><h3 id="mysql数据表的创建、修改、查看、删除"><a href="#mysql数据表的创建、修改、查看、删除" class="headerlink" title="mysql数据表的创建、修改、查看、删除"></a>mysql数据表的创建、修改、查看、删除</h3><blockquote><p>阿里巴巴开发手册中的mysql建表规约里有如下【强制】规范：<br><img src="../images/2020-12-13-14-50-30.png"></p></blockquote><ol><li><p>创建数据表</p><blockquote><p>mysql创建数据表通用语法</p></blockquote> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> table_name (column_name column_type);</span><br></pre></td></tr></table></figure> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> <span class="string">`student`</span>(</span><br><span class="line"><span class="string">`student_id`</span> <span class="built_in">INT</span> <span class="keyword">UNSIGNED</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">&#x27;学生唯一id&#x27;</span>,  <span class="comment">--学生的id，定义成无符号自动增长</span></span><br><span class="line"><span class="string">`student_name`</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">COMMENT</span> <span class="string">&#x27;学生姓名&#x27;</span>,   </span><br><span class="line"><span class="string">`student_age`</span> <span class="built_in">int</span>(<span class="number">3</span>) <span class="keyword">COMMENT</span> <span class="string">&#x27;学生年龄&#x27;</span>, </span><br><span class="line"><span class="string">`gmt_create`</span> DATETIME <span class="keyword">COMMENT</span> <span class="string">&#x27;记录创建时间&#x27;</span>, </span><br><span class="line"><span class="string">`gmt_modified`</span> DATETIME <span class="keyword">COMMENT</span> <span class="string">&#x27;记录修改时间&#x27;</span>, </span><br><span class="line">PRIMARY <span class="keyword">KEY</span> ( <span class="string">`student_id`</span> )  <span class="comment">--指定该表的主键</span></span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8 <span class="keyword">COMMENT</span> <span class="string">&#x27;学生表&#x27;</span>;  <span class="comment">--指定数据表执行引擎和数据表的默认字符集</span></span><br></pre></td></tr></table></figure><p><img src="../images/2020-12-13-18-40-49.png"></p></li><li><p>修改数据表(ALTER…ADD, ALTER …DROP)<br> 2.1 为student表增加字段性别</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">ADD</span> <span class="string">`sex`</span> <span class="built_in">varchar</span>(<span class="number">3</span>) <span class="keyword">COMMENT</span> <span class="string">&#x27;学生性别&#x27;</span>;</span><br></pre></td></tr></table></figure><p><img src="../images/2020-12-13-18-45-23.png"></p><p> 2.2 删除student的性别字段</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">`student`</span> <span class="keyword">DROP</span> <span class="string">`sex`</span>;</span><br></pre></td></tr></table></figure><p><img src="../images/2020-12-13-18-46-13.png"></p></li><li><p>查看数据表及表结构<br> 3.1 查看所有数据表(SHOW TABLES)</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure><p> 3.2 查看表结构(SHOW COLUMNS FROM table_name)</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> student;</span><br></pre></td></tr></table></figure><p><img src="../images/2020-12-13-18-49-19.png"></p></li><li><p>删除数据表(DROP TABLE table_name)</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> student ;</span><br></pre></td></tr></table></figure><p><img src="../images/2020-12-13-20-11-39.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode练习题11-盛水最多的容器</title>
      <link href="/a25ed364.html"/>
      <url>/a25ed364.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是leetcode题库的第11题 - <a href="https://leetcode-cn.com/problems/container-with-most-water/">盛水最多的容器</a></p></blockquote><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><blockquote><p>盛水面积 = 长(两条边的数组下标之差的绝对值) x 宽(两条变的高度中较小的一条边)<br><img src="../images/2020-12-12-17-56-07.png"></p></blockquote><ol><li>以官方第一个示例作为分析，我们可以用两个指针分别指向数组的第一个元素和最后一个元素，即left为0，right为height.length -1,初始容积是 (height.length -1 -0) * min(height[0], height[height.length-1]),上图中即是(8-0) x 1 = 8;</li><li>然后用双指针i, j遍历height数组。对于height[i]和height[j]两条边，我们总是期望能保留比较高的一条边，然后放弃比较低的一条边，另寻一条相对比较高的边来使容积增大。</li><li>因此，我们在获取初始面积后，如果height[i] &lt; height[j],那我们尝试i + 1，去找一条更高的变，i+1 后，再按照步骤1的计算方法计算新的容器的容积，如果计算结果比现有的大，那就把i赋值给left。同理如果height[i] &gt; height[j],那我们尝试j - 1，去找一条更高的变，j-1 后，再按照步骤1的计算方法计算新的容器的容积，如果计算结果比现有的大，那就把j赋值给right。</li><li>当遍历完height数组(i &gt;= j)，left和right指针就分别指向了容积最大两条边，即可按照步骤1的计算方法算出最大容积area返回。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> area = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(height != <span class="keyword">null</span> &amp;&amp; height.length &gt; <span class="number">1</span>)<span class="comment">//注意处理边界条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">//最大容积的左边指针</span></span><br><span class="line">        <span class="keyword">int</span> right = height.length -<span class="number">1</span>;<span class="comment">//最大容积的右边指针</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = height.length -<span class="number">1</span>; i &lt; j;) &#123;</span><br><span class="line">            <span class="keyword">if</span>(((j-i) * Math.min(height[i], height[j])) &gt; ((right - left) * Math.min(height[right], height[left])))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果此次计算的容积比现有的大，即把i赋值给left，j赋值给right，更新现有的最大容积指针</span></span><br><span class="line">                left = i;</span><br><span class="line">                right = j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果此次计算容积比现有小，把数值小的一边舍弃，寻找数值更大的边。</span></span><br><span class="line">            <span class="keyword">if</span>(height[i] &gt; height[j])</span><br><span class="line">            &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        area = (right -left) * (Math.min(height[left], height[right]));<span class="comment">//计算最终最大容积</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> leetcode </tag>
            
            <tag> 对撞指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM内存模型</title>
      <link href="/3e83b217.html"/>
      <url>/3e83b217.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>JVM1.6内存模型如下：</p></blockquote><p><img src="../images/2020-12-07-23-06-42.png"></p><h2 id="1-程序计数器-Program-Counter-Register"><a href="#1-程序计数器-Program-Counter-Register" class="headerlink" title="1 程序计数器(Program Counter Register)"></a>1 程序计数器(Program Counter Register)</h2><p> 程序计数器是线程私有的，是一个比较小的内存空间。它可以看作是当前线程当前字节码执行的行号指示器。在线程切换后也依赖程序计数器来使线程回到正确的位置继续执行。如果当前线程执行的是Java方法，程序计数器记录的当前执行的字节码指令在内存中的地址，如果执行的是本地native方法，程序计数器记录的空(undefied)。PS:<br> 程序计数器也是jvm运行时数据区中唯一没有OutOfMemoryError出现的区域</p><h2 id="2-虚拟机栈-Java-Vitual-Mechine-Stack"><a href="#2-虚拟机栈-Java-Vitual-Mechine-Stack" class="headerlink" title="2.虚拟机栈(Java Vitual Mechine Stack)"></a>2.虚拟机栈(Java Vitual Mechine Stack)</h2><p> 虚拟机栈也是线程私有的，它描述的是JVM执行java方法的内存模型，jvm每调用一个方法，都会创建一个栈帧，该栈帧中包含了此方法的局部变量表、操作数、动态链接、方法出口等信息。每个java方法从被调用到执行结束，就对应这它的栈帧从入栈到出栈的过程。因此，main方法作为java程序的入口，它的栈帧就在虚拟机栈的最底部，当main方法的栈帧出栈后，线程也就结束了。虚拟机栈的空间不是无限大的，当方法栈空间满了后，会抛出StackOverFlowError，例如深度过大的递归。在某些虚拟机实现中，虚拟机栈可以动态扩容，当动态扩容无法申请到更多内存时，会抛出OutOfMemoryError。</p><h2 id="3-本地方法栈-Native-Method-Stack"><a href="#3-本地方法栈-Native-Method-Stack" class="headerlink" title="3.本地方法栈(Native Method Stack)"></a>3.本地方法栈(Native Method Stack)</h2><p>本地方法栈与虚拟机栈的作用类似，它区别于虚拟机栈的地方是虚拟机栈是为java方法服务的，而本地方法栈则是为java调用的本地Native方法服务的，jvm调用本地Native方法的时候，会通过本地方法栈调用本地方法接口(Java Native Interface JNI),从而可以使java可以调用到本地方法库，例如c和c++的库。</p><h2 id="4-Java堆-Java-Heap"><a href="#4-Java堆-Java-Heap" class="headerlink" title="4.Java堆(Java Heap)"></a>4.Java堆(Java Heap)</h2><p>Java堆是jvm中所有线程共享的一块内存区域，几乎所有对象的实例化都在堆中完成。如果在堆中无法为实例分配内存，而且堆无法再扩展的时候，会抛出OutOfMemoryError。堆也是java垃圾收集器管理的主要区域(Garbage Collected)。关于堆的垃圾回收机制将在后面的笔记中补充。</p><h2 id="5-方法区-Method-Area"><a href="#5-方法区-Method-Area" class="headerlink" title="5.方法区(Method Area)"></a>5.方法区(Method Area)</h2><p>方法区是堆中的一块特殊区域，它也是线程共享的，用于存放已经被jvm加载的类信息、常量池、静态变量等数据。在HotSpot虚拟机jdk1.6版本是把方法区实现为永久代，在jdk1.7版本中把常量池从方法区中移出，放到堆中，而在jdk1.8中，移除了永久代，改用元空间来实现方法区。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型</title>
      <link href="/f7fe0af2.html"/>
      <url>/f7fe0af2.html</url>
      
        <content type="html"><![CDATA[<h2 id="java有8种基本数据类型及其包装类"><a href="#java有8种基本数据类型及其包装类" class="headerlink" title="java有8种基本数据类型及其包装类"></a>java有8种基本数据类型及其包装类</h2><pre><code>        （自动装箱）    --------------------&gt;    &lt;--------------------        （自动拆箱）byte    (1个字节)   ---&gt;    Byteshort   (2个字节)   ---&gt;    Shortint     (4个字节)   ---&gt;    Integerlong    (8个字节)   ---&gt;    Longfloat   (4个字节)   ---&gt;    Floatdouble  (8个字节)   ---&gt;    Doublechar    (2个字节)   ---&gt;    Charboolean (1个字节)   ---&gt;    Boolean</code></pre><h2 id="基本类型之间的类型转换规则"><a href="#基本类型之间的类型转换规则" class="headerlink" title="基本类型之间的类型转换规则"></a>基本类型之间的类型转换规则</h2><blockquote><p>boolean类型不参与类型转换，其他7种类型按照以下规则转换</p></blockquote><ol><li>如果运算符任意一方的类型为double，则另一方会转换为double</li><li>否则，如果运算符任意一方的类型为float，则另一方会转换为float</li><li>否则，如果运算符任意一方的类型为long，则另一方会转换为long</li><li>否则，两边都会转换为int</li></ol><h2 id="基本数据类型中一些有意思的现象"><a href="#基本数据类型中一些有意思的现象" class="headerlink" title="基本数据类型中一些有意思的现象"></a>基本数据类型中一些有意思的现象</h2><h3 id="boolean与Boolean"><a href="#boolean与Boolean" class="headerlink" title="boolean与Boolean"></a>boolean与Boolean</h3><p>boolean类型只有<strong>true</strong>和<strong>false</strong>两个值，在底层使用0(false)和1(true)存储，所以它需要一个字节来存储。<br>通过自动拆箱给boolean变量初始化时，如果送入包装类Boolean的初始化参数为String类型，则送入”true”,则返回一个true，其余情况都是返回false，如下传入”aaa”，得到的boolean值为false</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> o1 = <span class="keyword">new</span> Boolean(<span class="string">&quot;true&quot;</span>);  <span class="comment">//true</span></span><br><span class="line"><span class="keyword">boolean</span> o2 = <span class="keyword">new</span> Boolean(<span class="string">&quot;aaa&quot;</span>);  <span class="comment">//false</span></span><br></pre></td></tr></table></figure><p>Boolean送入String的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Boolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parseBoolean(s));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">parseBoolean</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((s != <span class="keyword">null</span>) &amp;&amp; s.equalsIgnoreCase(<span class="string">&quot;true&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="int和Integer"><a href="#int和Integer" class="headerlink" title="int和Integer"></a>int和Integer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i1 = <span class="number">127</span>;</span><br><span class="line">        Integer i2 = <span class="number">127</span>; <span class="comment">//自动装箱：Integer i2 = Integer.valueOf(127);</span></span><br><span class="line">        Integer i3 = <span class="number">127</span>; </span><br><span class="line">        Integer i4 = <span class="keyword">new</span> Integer(<span class="number">127</span>);</span><br><span class="line">        <span class="keyword">int</span> i6 = <span class="number">128</span>;</span><br><span class="line">        Integer i7 = <span class="number">128</span>;</span><br><span class="line">        Integer i8 = <span class="number">128</span>;</span><br><span class="line">        Integer i9 = <span class="keyword">new</span> Integer(<span class="number">128</span>);</span><br><span class="line">        System.out.println(i1 == i2); <span class="comment">//true    //自动拆箱</span></span><br><span class="line">        System.out.println(i2 == i3); <span class="comment">//true    //IntegerCache范围是-128~127，所以两次Integer.valueOf()返回的都是IntegerCache里面同一个对象，所以相等</span></span><br><span class="line">        System.out.println(i1 == i4); <span class="comment">//true    //int与Integer用==进行比较,Integer自动拆箱为int类型，所以相等</span></span><br><span class="line">        System.out.println(i6 == i7); <span class="comment">//true    //自动拆箱</span></span><br><span class="line">        System.out.println(i7 == i8); <span class="comment">//false   //128没在IntegerCache里面，所以两次Integer.valueOf()返回了不同的包装类对象，所以不相等</span></span><br><span class="line">        System.out.println(i7 == i9); <span class="comment">//false   //包装类为对象，只要比较的两个其中有一个为new创建的，==比较的就是两个不同的对象，所以不相等</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JDK1.8中Integer.valueOf()和Integer缓存池源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)]; <span class="comment">//如果在-128~127之间，返回IntegerCache里面的Integer</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);<span class="comment">//如果不在-128~127之间，返回new Integer(i);</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部类 IntegerCache</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue =</span><br><span class="line">            sun.misc.VM.getSavedProperty(<span class="string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="float和double"><a href="#float和double" class="headerlink" title="float和double"></a>float和double</h3><blockquote><p>float和double作为浮点数，在计算过程中，容易造成精度丢失问题，所以在金额的计算，例如银行等金融机构的业务中，应该避免使用浮点数来存储金额数据，为确保精确，应使用java.math.BigDecimal。</p></blockquote><h3 id="浮点数运算小数带来精度丢失问题"><a href="#浮点数运算小数带来精度丢失问题" class="headerlink" title="浮点数运算小数带来精度丢失问题"></a>浮点数运算小数带来精度丢失问题</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f1 = <span class="number">0.1f</span>;    <span class="comment">//0.1</span></span><br><span class="line"><span class="keyword">double</span> d1 = <span class="number">1.0</span>/<span class="number">10</span>; <span class="comment">//0.1</span></span><br><span class="line"><span class="keyword">float</span> f2 = <span class="number">1.0f</span>/<span class="number">10</span>; <span class="comment">//0.1</span></span><br><span class="line">System.out.println(f1 == d1);   <span class="comment">//false</span></span><br><span class="line">System.out.println(f2 == d1);   <span class="comment">//false</span></span><br><span class="line">System.out.println(f1 == f2);   <span class="comment">//true</span></span><br><span class="line">System.out.println(f1 * f2);    <span class="comment">//0.010000001</span></span><br><span class="line">System.out.println(<span class="string">&quot;=============================&quot;</span>);</span><br><span class="line"><span class="keyword">float</span> f3 = <span class="number">0.5f</span>;    <span class="comment">//0.5</span></span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">1.0</span>/<span class="number">2</span>; <span class="comment">//0.5</span></span><br><span class="line"><span class="keyword">float</span> f4 = <span class="number">1.0f</span>/<span class="number">2</span>; <span class="comment">//0.5</span></span><br><span class="line">System.out.println(f3 == d2);   <span class="comment">//true</span></span><br><span class="line">System.out.println(f4 == d2);   <span class="comment">//true</span></span><br><span class="line">System.out.println(f3 == f4);   <span class="comment">//true</span></span><br><span class="line">System.out.println(f3 * f4);    <span class="comment">//0.25  </span></span><br></pre></td></tr></table></figure><p>出现以上原因跟十进制小数如何转成二进制小数有关<br>    算法是乘以2直到没有了小数为止：</p><pre><code>0.1表示成二进制数：0.1*2=0.2       取整数部分 00.2*2=0.4       取整数部分 00.4*2=0.8       取整数部分 00.8*2=1.6       取整数部分 10.6*2=1.2       取整数部分 10.2*2=0.4       取整数部分 00.4*2=0.8       取整数部分 00.8*2=1.6       取整数部分 1.........0.1二进制表示为(从上往下): 00011001......</code></pre><p>有点类似10进制无法精确表示1/3，二进制也无法精确表示某些小数，计算时会有舍入误差。</p><h2 id="char"><a href="#char" class="headerlink" title="char"></a>char</h2><blockquote><p>所有的字符本质还是数字，所有的字符都在Unicode编码表里面找到对应的数字，范围是[0,65535),2的16次方，unicode编码用十六进制表示[u0000 - uFFFF];  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c3 = <span class="string">&#x27;\u0061&#x27;</span>; <span class="comment">//unicode 编码 16进制表示</span></span><br><span class="line"></span><br><span class="line">System.out.println(c1);         <span class="comment">//A</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)c1);    <span class="comment">//65</span></span><br><span class="line">System.out.println(c2);         <span class="comment">//中</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)c2);    <span class="comment">//20013</span></span><br><span class="line">System.out.println(c3);         <span class="comment">//a</span></span><br><span class="line">System.out.println((<span class="keyword">int</span>)c3);    <span class="comment">//97</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown写作入门</title>
      <link href="/d816cff7.html"/>
      <url>/d816cff7.html</url>
      
        <content type="html"><![CDATA[<h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><hr><h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>字体加粗</strong><br><em>字体倾斜</em><br><strong><em>字体倾斜+加粗</em></strong><br><del>删除线</del></p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><blockquote><p>千里之行,始于足下。——老子</p></blockquote><hr><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><hr><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><p><img src="../images/example.jpg" alt="截图1"><br><img src="https://highphone.xyz/images/2020-11-22-23-46-21.png" alt="截图2"></p><hr><h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><a href="https://htchz.cc/">土川的自留地</a></p><hr><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><ol><li>A</li><li>B</li><li>C</li></ol><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><ul><li>D</li><li>E</li><li>F</li></ul><hr><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table><thead><tr><th>名字</th><th>性别</th><th>生日</th></tr></thead><tbody><tr><td>法外狂徒张三</td><td>男</td><td>1997.7.7</td></tr></tbody></table><hr><h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">HelloWorld</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="最后贴上以上效果的-md文件代码截图"><a href="#最后贴上以上效果的-md文件代码截图" class="headerlink" title="最后贴上以上效果的.md文件代码截图"></a>最后贴上以上效果的.md文件代码截图</h2><p><img src="../images/2020-11-25-22-13-20.png"></p>]]></content>
      
      
      <categories>
          
          <category> 漫谈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA基础-String、StringBuffer、StringBuilder</title>
      <link href="/c570fbf2.html"/>
      <url>/c570fbf2.html</url>
      
        <content type="html"><![CDATA[<blockquote><p>折腾了这么久，终于把这个博客搭起来，作为第一篇文章，就挑了基础的爪哇字符串来写了。博客搭建过程多得土川大佬的指导，非常感谢！附上大佬的博客地址：<a href="https://htchz.cc/" title="[https:&#x2F;&#x2F;htchz.cc]" target>土川的自留地</a></p></blockquote><p><strong>String</strong><br>以下是String在jdk源码中的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence&#123;&#125;</span><br></pre></td></tr></table></figure><p>String在jdk源码中被声明为,是一个不可变类，String对象一旦被创建，其值将不能被改变，但String对象的引用是可变的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">    String str &#x3D; &quot;abc&quot;;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    System.out.println(System.identityHashCode(str));</span><br><span class="line">    str &#x3D; &quot;def&quot;;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">    System.out.println(System.identityHashCode(str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../images/2020-11-19-23-28-24.png"></p><p>以上代码中，创建了一个名为str的String对象并赋值为”abc”，后面经过str = “def”后，虽然输出str的值是变化了，但只是在字符串常量池创建了一个新的”def”，并把str的引用指向了它，并不是改变了原来字符串对象中”abc”的值，我们可以通过打印str=”def”前后的内存地址看出来。</p><p>虽然String是不可变的，但比较两个String对象是否相等不建议使用==，而是使用String重写继承自Object的eqauls()。</p><p>1.对于String常量s1 和 s2来说，其实其引用指向的都是字符串常量池中同一个字符串，所以使用==来比较这两个字符串，也是返回true。</p><p>2.对于s1 和 s3来说，s1是先去字符串常量中寻找是否有”abc”这个字符串，如果有，就把s1的引用指向它，如果没有，就生成一个”abc”字符串，放入字符串常量池中，并把s1的引用指向它；而对于String s3 = new String(“abc”)，如果常量池已有了”abc”，则只会在堆中生成一个新的值为”abc”的String对象，并把其引用给s3，如果常量池没有”abc”，这行代码则会生成两个值为”abc”的String对象，一个放入常量池中，一个在堆中，并把堆中的”abc”的引用给s3。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">   String s1 &#x3D; &quot;abc&quot;;</span><br><span class="line">   String s2 &#x3D; &quot;abc&quot;;</span><br><span class="line">   String s3 &#x3D; new String(&quot;abc&quot;);</span><br><span class="line"></span><br><span class="line">   System.out.println(s1 &#x3D;&#x3D; s2);&#x2F;&#x2F;true</span><br><span class="line">   System.out.println(s1 &#x3D;&#x3D; s3);&#x2F;&#x2F;false</span><br><span class="line">   System.out.println(s1.equals(s3));&#x2F;&#x2F;true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jdk1.8中String的eqauls()重写如下,使用eqauls来比较可以准确地判断两个String对象是否相等:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Compares this string to the specified object.  The result is &#123;@code</span><br><span class="line"> * true&#125; if and only if the argument is not &#123;@code null&#125; and is a &#123;@code</span><br><span class="line"> * String&#125; object that represents the same sequence of characters as this</span><br><span class="line"> * object.</span><br><span class="line"> *</span><br><span class="line"> * @param  anObject</span><br><span class="line"> *         The object to compare this &#123;@code String&#125; against</span><br><span class="line"> *</span><br><span class="line"> * @return  &#123;@code true&#125; if the given object represents a &#123;@code String&#125;</span><br><span class="line"> *          equivalent to this string, &#123;@code false&#125; otherwise</span><br><span class="line"> *</span><br><span class="line"> * @see  #compareTo(String)</span><br><span class="line"> * @see  #equalsIgnoreCase(String)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public boolean equals(Object anObject) &#123;</span><br><span class="line">    if (this &#x3D;&#x3D; anObject) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (anObject instanceof String) &#123;</span><br><span class="line">        String anotherString &#x3D; (String)anObject;</span><br><span class="line">        int n &#x3D; value.length;</span><br><span class="line">        if (n &#x3D;&#x3D; anotherString.value.length) &#123;</span><br><span class="line">            char v1[] &#x3D; value;</span><br><span class="line">            char v2[] &#x3D; anotherString.value;</span><br><span class="line">            int i &#x3D; 0;</span><br><span class="line">            while (n-- !&#x3D; 0) &#123;</span><br><span class="line">                if (v1[i] !&#x3D; v2[i])</span><br><span class="line">                    return false;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>StringBuffer</strong><br>StringBuffer一个可变类，当对象被创建后可以多次进行修改并且不会产生新的未使用对象，其初始化只能通过构造函数方式(new StringBuffer(“abc”))。同时，由于其提供的方法都进行了加锁，所以StringBuffer是线程安全的。<br>JDK源码中StringBuffer部分方法如下：<br><img src="../images/2020-11-22-20-05-00.png"></p><p><strong>StringBuilder</strong><br>JDK1.5之后才有，StringBuilder与StringBuffer类似，提供与StringBuffer相同的API，但不保证同步。在可能的情况下，建议使用这个类别优先于StringBuffer ，因为它在大多数实现中将更快。</p><p><strong>三者对比</strong><br>执行效率 ： StringBuilder  &gt;  StringBuffer &gt; String</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class StringTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        runAppend(100000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void runAppend(int n)</span><br><span class="line">    &#123;</span><br><span class="line">        String str &#x3D; &quot;&quot;;</span><br><span class="line">        Long strTimeStart &#x3D; System.currentTimeMillis();</span><br><span class="line">        for (int i&#x3D; 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            str +&#x3D; &quot;&quot; + i;</span><br><span class="line">        &#125;</span><br><span class="line">        Long strTimeEnd &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;append [&quot; + n +&quot;] times String cost time:&quot; + (strTimeEnd-strTimeStart) + &quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">        Long sbTimeStart &#x3D; System.currentTimeMillis();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sb.append(&quot;&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        Long sbTimeEnd &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;append [&quot; + n +&quot;] times StringBuffer cost time:&quot; + (sbTimeEnd-sbTimeStart) + &quot;ms&quot;);</span><br><span class="line"></span><br><span class="line">        StringBuilder sd &#x3D; new StringBuilder();</span><br><span class="line">        Long sdTimeStart &#x3D; System.currentTimeMillis();</span><br><span class="line">        for(int i &#x3D; 0; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sd.append(&quot;&quot; + i);</span><br><span class="line">        &#125;</span><br><span class="line">        Long sdTimeEnd &#x3D; System.currentTimeMillis();</span><br><span class="line">        System.out.println(&quot;append [&quot; + n +&quot;] times StringBuilder cost time:&quot; + (sdTimeEnd-sdTimeStart) + &quot;ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用以上代码验证三者的执行速度<br>当n = 10 时，三者执行速度看不出差别，String比其他二者慢了1ms<br><img src="../images/2020-11-22-23-44-43.png"></p><p>当n = 1000 时，可以看出String比StringBuffer和StringBuilder慢一些，但StringBuffer比StringBuilder慢了1ms<br><img src="../images/2020-11-22-23-45-18.png"></p><p>当n = 100000 时：<br><img src="../images/2020-11-22-23-46-21.png"></p><p>我们可以把数据规模提高到1000000，因为此时String已经需要花费比较长时间了，我们可以把相关代码注释，只比较StringBuffer和StringBuilder<br><img src="../images/2020-11-22-23-47-17.png"><br>可以看出执行速度 StringBuilder &gt; StringBuffer &gt; String, 且可得出，随着数据规模的增大，这执行速度的差别将越来越大</p><p><strong>总结</strong><br>1.执行效率 StringBuilder &gt; StringBuffer &gt; String,但在数据规模小的时候，其实可以优先使用String<br>2.因为String是不可变的，所以它是线程安全的，而StringBuffer因为有加锁，所以StringBuffer也是线程安全的，所以，在多线程下操作大量数据，应该优先考虑StringBuffer<br>3.因StringBuilder执行效率最高，但是他不是线程安全的，所以比较适合在单线程下操作大量数据。</p>]]></content>
      
      
      <categories>
          
          <category> Java基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
